
<!-- # JVM运行时数据区 -->

java将内存的管理权力全部交给了虚拟机


JVM所管理的内存区域图

![mode](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/mode.png)

# 程序计数器

程序计数器
- 是一块较小的内存空间，属于线程私有的内存
- 可以看成是当前线程所指向的字节码的行号指示器
- 字节码解释器依靠计数器的值来选取下一个要执行的字节码指令
- 由于java是多线程的切换的方式实现的，为了保证切换回后有恢复到正确的位置，所以每一条线程都有一个计数器
- 线程指向java代码，则计数器记录正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器为Undefined
- 唯一一个没有规定任何OetOfMemoryError情况的区域

# Java虚拟机栈

Java虚拟机栈
- 线程私有的内存,为Java方法服务
- 生命周期鱼线程相同
- 每个方法在执行的同时会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息;每一个方法调用直到完成的过程，对应一个栈帧在虚拟机栈中的入栈到出栈
- 规定了两种异常状态  
    StackOverflowError: 栈溢出  
    OutOfMemoryError异常：无法申请到足够的内存  

局部变量表
- 也就是通常讲的栈内存
- 存放了编译期可知的基本数据类型、对象引用(reference类型，可能是执行对象起始地址的引用指针，可以能是指向代表对象的句柄或其他与此对象相关的位置)、returnAddress类型(指向一条字节码指令的地址)
- 基本数据类型的long和double会占据两个局部变量空间(Slot),其余数据类型占据一个
- 局部变量表在编译期就已经完成了内存空间的分配

# 本地方法栈

本地方法栈
- 与虚拟机栈类似，为Native方法服务
- 规定了两种异常状态  
    StackOverflowError: 栈溢出  
    OutOfMemoryError异常：无法申请到足够的内存  

# Java堆

Java堆：
- JVM内存最大的一块,被线程共享，在虚拟机启动时创建
- 用于存放对象示例
- 因为是垃圾收集器管理的主要区域，又被称为GC堆
- 根据分代收集算法，可分为新生代和老年代
- 如果没有内存完成示例分配，会抛出OutOfMemoryError异常

# 方法区
- 线程间共享
- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 别名：Non-Heap(非堆);
- 在HotSpot虚拟机上，又可以被称为"永久代"(因为HotSpot虚拟机使用永久代来实现方法区，好处是可以使用垃圾收集器管理方法区内存，不用另外写管理代码，其他虚拟机不存在永久代)；使用永久代实现方法区更容易导致内存溢出，所以官方正逐步改为Native Memory来实现方法去;在JDK 1.7的HotSpot，已经将字符串常量池移出


运行时常量池
- 属于方法区的一部分
- 用于存放编译期生成的各种字面量和符号引用
- 无法申请到内存时抛出OutOfMemoryError异常

# 直接内存

 直接内存：非虚拟机运行时数据区的一部分，也不是虚拟机规范中的内存区域，但经常被使用;在JDK1.4后加入了NIO类，引入了基于通道与缓冲区的I/O方式，该类可以使用Native函数库直接分配堆外内存，然后通过一个存储在 *java堆* 中的 *DirectByteBuffer*对象作为这块额你存的引用进行操作;会受到本机总内存以及处理器寻址空间的限制。会抛出OutOfMemoryError异常

