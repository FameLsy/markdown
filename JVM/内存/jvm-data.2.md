

<!-- # HotSpot虚拟机对象 -->

# 对象的创建

从语言层面上，创建一个对象只是使用new关键字，而在虚拟机中，当遇到一个new指令，执行步骤如下
1. 检查这个指令的参数能够在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析、初始化；如果没有，则先进行类加载
2. 在类加载检查通过后，虚拟机为新的对象分配内存
3. 将分配到的内存空间初始化为0
4. 对对象进行必要设置，如设置对象是哪个类的示例，对象的hash code等,而这些信息存放在 *对象头* 中

## 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储布局分三块区域
1. 对象头
2. 实例数据
3. 对齐填充

对象头包括两部分信息
- 第一部分：存储对象自身的运行时数据，这部分数据被称为 被称为 *Mark Word*， 是一个非固定的数据结构，它会根据对象的状态复用自己的存储空间
- 第二部分:类型指针，虚拟机通过该指针确定对象是哪个类的实例；如果是数组，对象头还需要一个额外的数据记录数组长度

对象头 Mark Word:
![markword](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/markword.png)


实例数据是对象真正存储的有效信息，也就是程序代码中定义的各种类型的字段内容，包括父类继承和子类本身定义。该信息的存储信息顺序受到虚拟机分配策略参数和字段在java源码中定义的顺序影响。

对齐填充不是必须存在的，仅仅起到占位符的作用，如HotSpot要求对象地址必须是8的倍数。

# 对象的访问定位

为了使用对象，必须从栈上的renference数据来操作对上的具体对象。对于对象的访问方式，取决于虚拟机，目前主流方式有使用句柄和直接指针两种。

使用句柄访问：
- java会在堆中划分出一块内存来当句柄池
- reference中存储的对象就是句柄地址
- 句柄中包含了对象的实例数据与类型数据的具体地址

![jvm](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm.png)

使用直接指针
- reference中存储的对象就是对象实例数据的地址

![jvm2](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm2.png)

两种方式的优势
- 使用句柄访问最大好处就是reference稳定，对象移动时无需更改reference,只会改变j句柄中的实例数据指针
- 使用直接指针好处就是速度快，少一层指针定位的时间开销(HotSpot使用这种方式)