<!-- 对象存活判定算法-->

# 引用计数法

算法步骤
1. 给对象添加一个引用计数器
2. 每当有地方引用它，计数器+1
3. 引用失效，计数器-1
4. 计数器为0则表示没有任何地方使用这个对象

这是一个简单又高效的算法，但JVM并没有使用它，原因时它无法解决对象之间的相互循环引用问题;

```
//像这样的情况就被称为相互循环引用，会使这两个对象的计数器永远不为0
objA.instance = objB;
objB.instance = objA;
```

# 可达性分析算法

算法步骤
1. 通过一系列 *GC Roots* 作为对象的起始点
2. 从这些起始节点向下搜索，搜索走过的路径被称为 *引用链* 
3. 如果一个对象没有任何引用链，证明此对象不可用

如图，虽然object 5、6、7之间相互关联，但它们与 *GC Roots*无关联，所以会被判定为可回收对象

![jvm3](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm3.png)

在Java语言中，可作为 *GC Roots* 的对象包括
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法去区中常量引用的对象
- 本地方法栈中JNI(即Native方法)引用的对象

在可达性分析算法中，对于不可用的对象，并不会马上回收，它至少要经理两次标记过程
1. 第一次进行可达性分析后没有与GC Roots相连的引用链，则标记第一次；
2. 在标记完后，进行依次筛选，如果当前对象没有覆盖finalize()方法或者finalize()方法已经被JVM调用过，JVM会将这两种情况视为"没必要执行"，然后将该对象放入到 *F-Queue* 队列中，由一个虚拟机自动建立的，优先级低的Finalizer线程去执行它。GC 会对该队列进行第二次标记，如果在此时对象与引用链上的对象建立关联，则将该对象移出即将回收集合。如果第二次标记时仍然时不可达对象，那么就被真正回收


# 引用

什么是引用?
- 在JDK1.2 以前，引用被定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用
- 在JDK1.2之后，引用被分为了四种: *强引用、软引用、弱引用、虚引用*,四种引用强度依次减弱

强引用指在程序代码之中普遍存在的，类似"Object obj = new Object()"这类引用，只要强引用还在，垃圾收集器不会回收被引用的对象

软引用：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果还没有足够的内存，则抛出内存溢出异常。在JKD1.2后使用 *SoftReference* 类 来实现软引用

弱引用：弱引用关联的对象，在垃圾收集器工作时，无论是否内存足够，都会被回收。在JKD1.2后使用 *WeakReference* 类来实现软引用

虚引用：又被称为幽灵引用或者幻影引用。对象被虚引用关联，完全不会对其生存时间造成任何影响，也无法通过虚引用来获取对象实例。该引用的唯一作用是在被关联对象回收后收到一个系统通知；在JKD1.2后使用 *PhantomReference* 类来实现软引用

# 方法区的回收

方法区（即永久代）垃圾回收率较低，主要回收的时废弃常量和无用的类。废如字符串"abc"在常量池但没有任何对象引用用它，则该字符串就是废弃常量；而判断无用的类，则必须满足以下三个条件
1. 该类实例都已经被回收
2. 加载该类的ClassLoader已被回收
3. 该类的java.lang.Class对象没有被引用，无法在任何地方通过反射访问该类方法

满足三个条件，只能说是可以回收，是否要回收，HotSpot提供了 *-Xnoclassgc* 参数对齐进行控制;还可以使用 *-verbose:class*(Product版虚拟机中使用) 和 *-XX:+TraceClassLoadd*(Product版虚拟机中使用) 、 *-XX:+TraceClassUnLoading* (FastDebug版虚拟机中使用) 查看加载和卸载信息;

