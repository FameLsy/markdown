<!-- 垃圾收集器 -->
相关概念补充：
- 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。
- 吞吐量：COU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用于代码时间+垃圾回收时间)

# HotSpot 提供的收集器

收集器的连线表示它们可以配合使用

![jvm7](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm7.png)

# Serial 收集器

Serial收集器是一个 *单线程收集器* ,它只会使用一条垃圾收集线程去完成垃圾收集工作，它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（有一种叫法，叫 *Stop The World* ），直到它收集结束;它时JVM运行在 *Client模式* 下的默认 *新生代收集器* ,它的优点在于简单高效，尤其是单个CPU环境。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率

![jvm8](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm8.png)

# ParNew 收集器

ParNew收集器其实就是Serial收集器的并行多线程版本,其余行为与Serial收集器相同；是运行在Server模式下的JVM的首选收集器，有一个重要的原因是它能与COMS收集器配置。

![jvm9](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm9.png)


# Parallel Scsvenge收集器

Parallel Scsvenge收集器是一个 *新生代收集器*没使用的是 *复制算法*,同时也是并行的多线程收集器,与ParNew 收集器几乎一直，特点时它的关注点与其他收集器不同；其目标是达到一个可控制的吞吐量。它提供了两个参数用于精确控制吞吐量
1. -XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间(大于0的毫秒数)，收集器尽可能保证内存回收花费时间不超过设定值，时间缩短靠的是牺牲吞吐量和新生代空间换取的
2. -XX:GCTimeRatio 直接设置大小（大于0小于100，垃圾手机时间占总时间的比率，即吞吐量的倒数）,如设置成19，那么GC时间就是 1/(1+19)= 5%,默认值99，即GC时间1%(1/(1+99))

与ParNew收集器的另一个区别是 *GC自适应的调节策略*,这跟Parallel Scsvenge收集器的另一个参数 *-XX:+UserAdaptiveSizePolicy*有关，这是一个开复安参数，打开后，无需手工指定新生代大小、Eden与Survior的比例等细节参数，JVM会自动调节。 

# CMS收集器

CMS收集器是以获取最短回收停顿时间为目标的收集器，它是基于 *标记清除算法*实现的，它的运作过程如下
- 初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；需要"Stop The World"
- 并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短;需要"Stop The World"
- 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫

CMD也被称为 *并发低停顿收集器*，但存在3个缺点：
- CMS对CPU敏感：默认启动的回收线程数为(CPU数量+3)/4，当CPU的数量在4个以上时，那么并发回收时垃收集线程占了不少于25%的CPU资源，这个百分数值随着CPU输了增加而下降。然而，在CPU不足4个时，比如2个，那么开启的线程数为1，占了50%的CPU资源，这样很可能导致用户程序的执行速度降低50%。
- CMS收集器无法处理浮动垃圾。
- CMS式基于*标记清除算法*实现，所以会产生大量空间碎片。(CMS提供了 *-XX:+UseCMSCompactAtFullCollection* 开关参数,默认开启，用以在进行FullGC时开启内存碎片整理，但整理碎片会导致停顿时间变长；)

![jvm10](https://raw.githubusercontent.com/FameLsy/Images/master/javamode/jvm10.png)

# G1收集器


G1时面行服务端应用的垃圾收集器，它的目的在未来可以替换掉CMS收集器，它的特点如下
- 并发与并行：G1可以利用多个CPU以并发的方式让Java程序在执行GC的时候继续执行，以此来缩短 Stop The World 停顿时间，
- 分代收集：保留了分代的概念
- 空间整合：从整体看，G1是基于 *标记整理算法*实现的；从局部(Region)来看，G1是基于 *复制算法*实现的；这两种算法都不会产生内存空间碎片
- 可预测的停顿：相对于CMS的大优势，G1可以建立可预测的停顿时间模型，让使用者明确指定一个长度为M毫秒的时间片段，消耗在垃圾收集上的时间不得超过M秒。

G1收集器Java堆的内存布局与其他收集器有较大区别，它将整个Java堆划分成大小相等的独立区域(Region),虽然保留新生代和老年代概念，但新生代和老年代不再物理隔离，都属于Region(不需要连续)的集合；

G1收集器的运作大致分为以下几个步骤：
- 初始标记
- 并发标记
- 最终标记
- 筛选回收