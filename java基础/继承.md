---
title: java 基础:继承
date: 2018-02-02 00:00:07
tags: 
- 继承
categories:
- JavaSe教程
---


# 继承
关键字 extends 表示继承

## 成员的访问与继承
子类方法不能够直接地访问超类的私有域。需要通过super调用父类的getter方法。

子类继承了父类的所有属性和方法或子类拥有父类的所有属性和方法，只不过父类的私有属性和方法，子类是无法直接访问到的。即只是拥有，但是无法使用

## super

### 用法一：作为引用的关键字
子类可以通过spuer调用超类中定义的构造函数方法
```java
super(parameter-list);
```

super( )必须是在子类构造函数中的第一个执行语句。

super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。  

### 用法二：类似于this的用法

```java
//member既可以是1个方法也可以是1个实例变量
super.member
```
## 方法重写(override）

如果子类中的一个方法与它超类中的方法有相同的方法名和类型声明,称子类中的方法重写(override)超类中的方法

方法重写应遵循“三同一小一大”原则：  
>“三同”：即方法名相同，形参列表相同，返回值类型相同；  
>“一小”：子类方法声明抛出的异常比父类方法声明抛出的异常更小或者相等；  
>“一大”:子类方法的访问修饰符应比父类方法更大或相等。  

## 子类构造器
因为子类不能直接访问父类的私有域，所以必须利用父类的构造器对部分私有域进行初始化。  

通过 super 实现对超类构造器的调用。  

super 调用构造器的语句必须是子类构造器的第一条语句。  

子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 ) 的构造器。  
如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类 的其他构造器’ 则 Java 编译器将报告错误  

# 多态

一个对象可以指示多种实际类型的现象被成为多态。

当一个子类对象的引用被赋给一个超类引用变量时,你只能访问超类定义的对象的那一部分(即由父类引用子类对象，无法调用子类的特有方法。)

子类引用父类对象，需要强转。  

## 动态绑定
动态方法调度是一种在运行时而不是编译时调用重载方法的机制,即在运行时能够自动地选择调用哪个方法的现象被称为动态绑定，这是Java实现运行时多态性的基础



## 理解方法调用
当一个重载方法通过超类引用被调用,Java根据当前被引用对象的类型来决定执行哪个版本的方法

调用过程的详细描述：

1. 编译器査看对象的声明类型和方法名。【编译器已获得所有可能被调用的候选方法，同名不同参数的方法】  
2. 接下来，编译器将査看调用方法时提供的参数类型【编译器已获得需要调用的方法名字和参数类型。】。编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后 有多个方法与之匹配， 就会报告一个错误。
3. 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding )。
4. 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实 际类型最合适的那个类的方法。。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了 方法 f(String，) 就直接调用它；否则， 将在 D 类的超类中寻找 f(String，) 以此类推。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个 方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正 调用方法的时候， 虚拟机仅查找这个表就行了。

# 继承中使用final

## 使用final阻止重写
声明成final的方法不能被重载

## 使用final阻止继承
声明成final的类不能被继承


# 继承的设计技巧

1. 将公共操作和域放在超类
2. 不要使用受保护的域
3. 使用继承实现“ is-a” 关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态， 而非类型信息
```java
//如下情况，考虑多态，即将方法写入两个类的父类或接口中
if (x is of type1){
    action1(x)
}else if(x is of type2){
    action2(x)
}
```

7. 不要过多地使用反射
