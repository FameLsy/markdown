<!-- ---
title: Mybatis环境搭建
date: 2019-02-28 00:00:03
tags: 
- Mybatis环境搭建
categories: 
- Mybaits
--- -->

# 基础架构


MySQL基础架构示意图
-  MySQL分为Server层和存储引擎层两部分

![](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png)

Server层：
- 包括连接器、查询缓存、分析器、优化器、执行器等，蕴含MySQL大量核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等
- 多个存储引擎共用一个Server层

存储引擎层：
- 负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。
- 现在最常用的存储引擎是InnoDB,从MySQL5.5开始变为默认存储引擎

## 连接器

负责跟客户端建立连接，获取权限、维持和管理连接。

一般的连接命令：
```mysql
mysql -h$ip -P$port -u$user -p
```

连接命令中的mysql是客户端工具，用来跟服务器连接。在完成经典的 TCP 握手后，连接器开始认证身份，然后输入密码
- 用户名或密码不对， "Access denied for user"的错误，然后客户端程序结束执行
- 认证通过，连接器从权限表查询出用户的权限。之后这个连接里的权限判断逻辑，都依赖于此时读到的权限(也就意味着建立连接后用户的权限被修改也不会影响当前连接，除非建立新的连接才会生效改动)

连接之后，可以用以下命令查看连接状态
```
show processlist
```
Command显示 Sleep 这一列，表示当前用户处于空闲状态

![show-processlist](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/show-processlist.png)

对于空闲状态，客户端如果长时间没有动作，连接器是会自动断开它的，默认为8h，由 **wait_timeout** 参数控制

断开之后再发请求，会受到错误提示:"Lost connection to MySQL server during query",此时需要重新连接了

数据库连接:
- 长连接：如果客户端持续有请求，则一直使用同一个连接
- 短链接：每次执行完很少的查询就断开连接，下次查询再重新建立连接

建立连接过程复杂，所以尽量使用长连接
- 缺点：有时候MySQL占用内存涨得特别快
- 原因：MySQL在执行过程中临时使用的内存管理在连接对象里面。这些资源会在断开连接时才释放。所以长连接累积下来，会导致内存占用过大，被系统强制杀掉（OOM），从现象看是MySQL异常重启

解决长连接内存占用过大问题
1. 定期断开长连接，使用一段时间或程序里面执行过一个占用内存过大的查询后
2. MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后，通过 mysql_reset_connection来重新初始化连接资源（不需要重复验证，但连接会恢复成最初状态）

## 查询缓存

MySQL可能会将执行过的**查询语句和结果**，会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果执行的查询语句能够直接在这个缓存中找到key，如果能**命中缓存**，那么这个value就会被直接返回给客户端，这样效率会高很多

并不推荐使用！！！
- 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空
- 将参数query_cache_type设置成DEMAND关闭
- MySQL8.0删除

## 分析器

没有命中缓存，分析器会如下运作
1. 先做“词法分析”，如从 SELECT 识别出这是一个查询语句，从t_table识别成表名t_table,把id识别成列id
2. 再做"语法分析",语法分析器会检查你的SQL语句是否满足MySQL语法,如果语法出错，会提示"You have an error in your SQL syntax"

## 优化器

经过分析器之后，MySQL已经知道需要做什么，但在执行之前，需要优化。

优化器是在表里面有多个索引的时候，决定使用那个索引。或者在一个语句有多表关联（join）的时候，决定各个表达的连接顺序。

如下代码
- 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
- 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。
- 两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案

```
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

## 执行器

执行器首先会判断是否有相应的权限，无则返回错误提示。

有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，如下代码
- 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
- 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
- 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
```
mysql> select * from T where ID=10;
```




在慢查询日志中可以看到一个 **rows_examined** 字段，表示这个语句执行过程中扫面了多少行（也有可能不完全相同）