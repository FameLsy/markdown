<!-- MySQL中的锁 -->
根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类

# 全局锁
全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 
```
#让整个库处于只读状态（FTWRL）
Flush tables with read lock
```
使用该命令后，以下语句被阻塞:数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句

全局锁的典型使用场景是，做全库逻辑备份;

但是让库只读，有以下弊端
- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟

官方自带的逻辑备份工具是**mysqldump**。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于**MVCC**的支持，这个过程中数据是可以正常更新的(可重复读隔离级别可以获取一致性视图)

有了**single-transaction**，为什么还要FTWRL?
- 并不是所有的引擎都支持事务，如MyISAM，备份就需要FTWRL方法了。

另一种让全库进入只读状态的方法
```
set global readonly=true
```
但是推荐使用FTWRL，原因：
- 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大
- 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

事务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的
# 表级锁

MySQL里面表级别的锁有两种：
1. 表锁
2. 元数据锁（meta data lock，MDL)

## 表锁

语法
```
# 加锁
 lock tables <table-name> read/write[,<table-name> read/write]
# 释放锁,断开连接时也会自动释放
 unlock tables
```

注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象,如在线程A中执行以下语句
- 其他线程写t1、读写t2的语句都会被阻塞
- 线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作
```
lock tables t1 read, t2 write; 
```
## MDL锁

MDL(MySQL 5.5版本引入)不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查（DML）操作的时候，加MDL读锁；当要对表做结构变更操作(DDL)的时候，加MDL写锁
- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，如果对表进行操作不慎，会出现问题


![mysql10](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql10.jpg)

如上图所示
- Seesion A 启动，表会自动加上MDL读锁
- Seesion B启动，需要的也是MDL读锁，正常执行
- Session C启动，需要写锁，因为MDL读锁未释放，阻塞
- （关键）Session D启动，因为Session C阻塞后会对之后对锁的请求进行阻塞，所以Session D也被阻塞(客户端有重试机制，超时后会再起一个新session再请求的话，这个库的线程很快就会爆满)

那么如何安全的执行DDL?
- 解决长事务：在DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务
- 设定等待时间：在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句(MariaDB/AliSQL 已经支持 NOWAIT/WAIT 语法)

```
# 遗憾的是MySQL不支持
ALTER TABLE <tbl_name> NOWAIT add column ...
ALTER TABLE <tbl_name> WAIT N add column ... 
```

# 行锁

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁.MyISAM引擎就不支持行锁,InnoDB是支持行锁;行锁就是针对数据表中行记录的锁

## 两阶段锁

如下图所示，事务B的update语句会被阻塞(如果是MyISAM,不会阻塞，原因是只有表锁，DML语句都获取MDL读锁),这也说明了，事务A持有的两个记录的行锁

![mysql11](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql11.jpg)

在InnoDB事务中，行锁是在需要的时候才加上的，而是要等到事务结束时才释放。这个就是**两阶段锁协议**。此外，行锁锁的是索引。

如何优化行锁？

以电影票在线交易业务为例，
- 从顾客A账户余额中扣除电影票价；
- 顾客C要在影院B买票
- 给影院B的账户余额增加这张电影票价；
- 记录一条交易日志。

顾客A和C事务冲突，他们同时更新影院账户的余额，需要修改同一行数据。如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度;所以，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放

## 死锁和死锁检测

如图所示
- 事务A等待事务B释放id=2的行锁
- 事务B等待事务A释放id=1的行锁
- 两者均处于等待对方的资源释放，就是进入了死锁状态
![mysql12](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql12.jpg)

解决思索的策略
1. 通过参数innodb_lock_wait_timeout来设置超时时间(默认50s)
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on（默认on），表示开启这个逻辑

对于第一种方案，时间设置过长显然不行，而时间设置过短，如果只是简单的等待而不是死锁，因此退出事务，那么就会误伤了

所以，正常情况下我们还是要采用第二种策略,但死锁检测存在一个问题，那就是要耗费大量的CPU资源
- 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务

解决办法
- 如果能确保不发生死锁，可以临时关闭死锁检测（不推荐）
- 控制并发度，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低

对于控制并发度，一种是在客户端做并发控制，如每个客户端限制5个并发线程，但如果客户端数量过多，就不太行了。另一种是使用中间件，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了；还有一种方法是将一条更新记录拆分成逻辑上的多行来减少锁冲突，但业务复杂度可能会大大提高

