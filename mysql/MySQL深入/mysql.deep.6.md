<!-- RR与行锁，隔离还是不隔离 -->

对于RR隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样

对于行锁，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，会被锁住，进入等待状态

那么，如果事务进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么？

在MySQL里，有两个“视图”的概念：
- 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view ... ，而它的查询方法与表一样。
- 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

# 快照在MVCC里是怎么工作的

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。（注意，这个快照是基于整库的）
- 在事务开始时，会向InnoDB事务系统申请一个唯一的事务ID，transaction id，该id按申请顺序严格递增
- 当每个事务更新数据时，会生成新的一个数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id
- 更新语句同时会生成undo log（回滚日志），用于获取到旧的数据

如下图是一行数据被多个事务连续更新后的状态（commit之后）

![mysql13](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql13.png)

如图当前版本最新是V4，而V1,V2,V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的

那么，InnoDB是怎么定义那个“100G”的快照的？
- InnoDB为每个事务构造了一个数组，用来保存所有**启动了但还没提交的事务**ID
- 组里面事务ID的最小值记为**低水位**，当前系统里面已经创建过的事务ID的最大值加1记为**高水位**

![mysql14](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql14.png)

那么，当启动一个事务时，一个数据版本的row trx_id,有以下几种情况
1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；（低于低水位）
2. 果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；（高于高水位）
3. 如果落在黄色部分（数组部分），那就包括两种情况  
  a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；  
  b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见
  
如何以后的更新，生成的版本肯定是在2或者3a条件下，即不可见

总结：对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况
1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。


# 实例解析


```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```

如图所示结果为：事务B查到的k的值是3，而事务A查到的k的值是1（事务C没有begin/commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交；）

![mysql12](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql12.png)


假设
1. 事务A开始前，系统里面只有一个活跃事务ID是99；
2. 事务A、B、C的版本号分别是100、101、102，且当前系统里只有这三个事务；
3. 三个事务开始前，(1,1）这一行数据的row trx_id是90

![mysql15](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql15.png)

可以看到
1. 第一次更新操作由事务C完成，所以此时最新版本的row rex_id是102，90变为旧版本
2. 第二次更新操作由事务B完成，此时最新版本的row rex_id是103
3. 事务A开始读试图，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的
  a.找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见；
  b.接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见；
  c.再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。

为什么事务B读出来的是(1,3)?
1. 首先事务B创建试图肯定是先于事务C的
2. 如果在更新之前执行一次查询语句，读出来的确是是(1,1)
3. 但如果是更新操作，就会应用到一条规则：先读后写，而这个读，只能读当前的值，称为“当前读”（current read）
  a. 所以根据当前读的值，拿到的数据是(1,2),更新新版本后就是(1,3)了

# SELECT 语句加锁实现当前读

如果将A的查询语句加上**lock in share mode** 或 **for update**，也能读取版本号为101的数据

```
# 加了读锁（S锁，共享锁）
select k from t where id=1 lock in share mode;
# 加了写锁(写锁（X锁，排他锁）)
select k from t where id=1 for update;
```

原理：
1. 如果事务C更新语句且没有提交的话，那么必定会给该行添加了写锁
2. 事务A添加读锁或者写锁，因为事务C而堵塞，直到事务C提交位置
3. 以此事务B更新数据获取到行锁，如果事务C不提交的话，也会被堵塞

事务的可重复读的能力是怎么实现的？
- 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待

# 读提交

读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是
- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图


![mysql16](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/mysql16.png)

事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻： 
1. (1,3)还没提交，属于情况1，不可见；
2. (1,2)提交了，属于情况3，可见。


