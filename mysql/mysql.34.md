---
title: MySQL锁
tags: 
- MySQL
- 数据库
categories: 
- Database
---


# 简介

简介：
- 事务在对某个数据对象（如表、记录等）操作之前，先向系统发出请求，对其加锁，加锁后事务就对数据库对象有一定的控制，在事务释放它的锁之前，其他事务不能更新此数据对象。
- 数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问
- MySQL数据库由于存在多种数据存储引擎,每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别

MySQL各存储引擎使用了三种类型（级别）的锁定机制
- 行级锁定:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高
- 页级锁定:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
- 表级锁定:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低

MySQL这三种锁定的特点和各自的优劣所在
- 按照锁的粒度来分：行级锁、表级锁、页级锁定
- 按照锁的功能来分：共享读锁和排他写锁

各引擎对锁的支持
- MyISAM和MEMORY存储引擎采用的表级锁
- BDB采用的是页面锁，也支持表级锁
- InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。

## 排他锁

介绍:
- 又称写锁，X锁
- 允许当前请求进行读取和修改，同时阻塞其他请求读取和修改

## 共享锁
介绍:
- 又称读锁，S锁
- 允许当前请求进行读取，同时阻塞其他请求修改,但其他请求可以进行读取

## 行级锁

特点
- 行级别粒度，最小的粒度
- 由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能
- 更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用

缺点
- 锁定资源的颗粒度很小，占用系统资源大,并发度最高
- 过多的锁也最容易发生死锁

## 表级锁

特点
- 表级别粒度，最大的粒度
- 实现逻辑简单，带来的系统负面影响最小
- 获取锁和释放锁的速度很快
- 不会出现死锁
- 更适合于以查询为主，只有少量按索引条件更新数据的应用

缺点
- 出现锁定资源争用的概率高,并发度差

## 页级锁

特点
- MySQL特有的锁
- 所需资源和粒度都介于表级锁和行级锁之间
- 并发处理能力在三种锁之间最高

缺点
- 会发生死锁



# MyISAM引擎的锁机制

MyISAM只有表级锁
- 表共享读锁（table read lock）
- 表独占写锁（table write lock）。

MyISAM表的读、写操作之间、以及写操作之间的隔离级别是串行级别

流程：
- MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁
- 在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁
- 用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁

---
注意:MyISAM是不支持事务的

---

## MyISAM手动更改优先级

方式:
- 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
- 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。
- 给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。


## MyISAM的并发插入

MyISAM存储引擎有一个系统变量，concurrent_insert，专门用来控制并发插入行为的，值可以为0，1，2.
- 值为0：不允许插入
- 值为1：如果mysql没有空洞（中间没有被删除的行），MyISAM运行一个进程读表的时候，另一个进程从表尾插入记录，这也是mysql默认设置。
- 值为2，无论MyISAM表中有没有空洞，都允许在表尾并行的插入。


# InnoDB引擎的锁机制

与MyISAM不同:
- 支持事务
- 支持行级锁

流程
- 对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X）
- 对于普通SELECT语句，Innodb不会加任何锁。

## Innodb行锁模式以及加锁方法

Innodb锁模式一共分为
- 共享锁
- 排他锁
- 意向锁(意向共享锁、意向排他锁)

冲突情况：
||||||
|--|--|--|--|--|
||共享锁|排他锁|意向共享锁|意向排他锁|
|共享锁|兼容|冲突|兼容|冲突|
|排他锁|冲突|冲突|冲突|冲突|
|意向共享锁|兼容|冲突|兼容|兼容|
|意向排他锁|冲突|冲突|兼容|兼容|

## 表级锁和行级锁之间的冲突

如下情况
- 事务A：行级锁，锁定行H，只读
- 事务B：表级锁，锁定了行H的表，读写

数据库的解决办法: 意向锁
- 意向锁是一个表级锁，可以分为意向共享锁(IS)、意向排他锁（IX）
- 事务A必须先申请意向锁，再申请行级锁
- 事务B在申请表级锁时，发现表已经有了意向锁，会被阻塞