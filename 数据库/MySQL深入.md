
# 基础架构


当我们执行如下语句时，在MySQL内部时如何执行的?
```
SELECT * FROM t_table WHERE id = 10;
```

MySQL基础架构示意图
-  MySQL分为Server层和存储引擎层两部分

![](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png)

Server层：
- 包括连接器、查询缓存、分析器、优化器、执行器等，蕴含MySQL大量核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等
- 多个存储引擎共用一个Server层

存储引擎层：
- 负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。
- 现在最常用的存储引擎是InnoDB,从MySQL5.5开始变为默认存储引擎

## 连接器

负责跟客户端建立连接，获取权限、维持和管理连接。

一般的连接命令：
```mysql
mysql -h$ip -P$port -u$user -p
```

连接命令中的mysql是客户端工具，用来跟服务器连接。在完成经典的 TCP 握手后，连接器开始认证身份，然后输入密码
- 用户名或密码不对， "Access denied for user"的错误，然后客户端程序结束执行
- 认证通过，连接器从权限表查询出用户的权限。之后这个连接里的权限判断逻辑，都依赖于此时读到的权限(也就意味着建立连接后用户的权限被修改也不会影响当前连接，除非建立新的连接才会生效改动)

连接之后，可以用以下命令查看
```
show processlist
```
Command显示 Sleep 这一列，表示当前用户处于空闲状态

![show-processlist](https://raw.githubusercontent.com/FameLsy/Images/master/MySQL/show-processlist.png)

对于空闲状态，客户端如果长时间没有动作，连接器是会自动断开它的，默认为8h，由 wait_timeout 参数控制

断开之后再发请求，会受到错误提示:"Lost connection to MySQL server during query",此时需要重新连接了

数据库连接:
- 长连接：如果客户端持续有请求，则一直使用同一个连接
- 短链接：每次执行完很少的查询就断开连接，下次查询再重新建立连接

建立连接过程复杂，所以尽量使用长连接
- 缺点：有时候MySQL占用内存涨得特别快
- 原因：MySQL在执行过程中临时使用的内存管理在连接对象里面。这些资源会在断开连接时才释放。所以长连接累积下来，会导致内存占用过大，被系统强制杀掉（OOM），从现象看是MySQL异常重启

解决长连接内存占用过大问题
1. 定期断开长连接，使用一段时间或程序里面执行过一个占用内存过大的查询后
2. MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后，通过 mysql_reset_connection来重新初始化连接资源（不需要重复验证，但连接会恢复成最初状态）

## 查询缓存
连接创建完后，可以执行开始的查询语句了
```
SELECT * FROM t_table WHERE id = 10;
```

此时，执行逻辑来到了查询缓存

MySQL的做法是
- 拿到查询请求后，先到查询缓存看，是不是执行过该条语句。而之前执行过的语句和结果，可能以Key-value的方式缓存在内存中（key是查询语句，value是结果）,如果能在缓存中找到你的查询语句，直接从缓存中返回结果
- 没有在缓存中找到，那么就执行下一阶段。等全部执行完成后，执行结果会被存入查询缓存中

通过查询缓存，可以显著的提高效率


## 分析器

没有命中缓存，分析器会如下运作
1. 先做“词法分析”，如从 SELECT 识别出这是一个查询语句，从t_table识别成表名t_table,把id识别成列id
2. 再做"语法分析",语法分析器会检查你的SQL语句是否满足MySQL语法,如果语法出错，会提示"You have an error in your SQL syntax"

## 优化器

经过分析器之后，MySQL已经知道需要做什么，但在执行之前，需要优化。

优化器是在表里面有多个索引的时候，决定使用那个索引。或者在一个语句有多表关联的时候，决定各个表达的连接顺序。

## 执行器

先判断是否有相应的权限，无则返回错误提示。

有权限，执行器根据表的引擎定义，去使用这个引擎提供的接口。

在慢查询日志中可以看到一个 rows_examined 字段，表示这个语句执行过程中扫面了多少行（也有可能不必完全相同）