<!-- MySQL中的锁 -->
根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类

# 全局锁
全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 
```
#让整个库处于只读状态（FTWRL）
Flush tables with read lock
```
使用该命令后，以下语句被阻塞:数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句

全局锁的典型使用场景是，做全库逻辑备份;

但是让库只读，有以下弊端
- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的(可重复读隔离级别可以获取一致性视图)

有了**single-transaction**，为什么还要FTWRL?
- 并不是所有的引擎都支持事务，如MyISAM，备份就需要FTWRL方法了。

另一种让全库进入只读状态的方法
```
set global readonly=true
```
但是推荐使用FTWRL，原因：
- 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大
- 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的
# 表级锁

MySQL里面表级别的锁有两种：
1. 表锁
2. 元数据锁（meta data lock，MDL)

## 表锁

语法
```
# 加锁
 lock tables <table-name> read/write[,<table-name> read/write]
# 释放锁,断开连接时也会自动释放
 unlock tables
```

注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象,如在线程A中执行以下语句
- 其他线程写t1、读写t2的语句都会被阻塞
- 线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作
```
lock tables t1 read, t2 write; 
```
## MDL锁

MDL(MySQL 5.5版本引入)不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁
- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，如果对表进行操作不慎，会出现问题

