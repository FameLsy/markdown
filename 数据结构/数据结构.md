---
title: 数据结构
tags: 
- 数据结构
categories: 
- 数据结构
---
教程链接：http://www.icourse163.org/learn/ZJU-93001?tid=1003013004&from=study#/learn/content

注：课程用的C，所有代码都是自己写的JAVA版本，可能有错~

1 线性结构
1.1 线性表（List）
由同类型数据元素构成的有序序列的线性结构

表中元素的个数称为线性表的长度
线性表没有元素时，称为空表
表起始位置称表头，表结束位置称表尾
线性表的主要操作：

List(): 初始化List
Object findKth(int k): 根据K来查找相应位置的元素
int find(Object x): 在List中查找X的第一次出现的位置
void insert(Object x, int i): 在i位置前插入一个x
void delete(i): 删除指定位置i的元素
int length(): 返回List的长度
1.1.1 线性表的顺序存储实现
 利用数组的连续存储空间顺序存放线性表的各元素

基本构成：

public class List {
        private Object[] elementData;//用于存放数据的数组
        private int last;//最后一个数组元素的索引
}
具体操作实现

长度：长度就是数组的大小

初始化操作： 空数组、last设为-1

    public List() {
        this.elementData =new Object[0];
        this.last = -1;
    }
查询元素所在位置：

    public int find(Object x){
        int i = 0;
        //从0开始找直到最后或者找到x，停止循环
        while (i <= last && elementData[i] != x) i++;
        //i 大于last时，表示找到最后一个没找到，返回-1
        if (i > last) return -1;
        //找到的话直接返回i就是x所在的位置
        else return i;
    }
插入操作：

 /**
     * 
     * @param x 要插入的元素
     * @param i 要插入的位置，i >= 1,因为0前面是没有索引的
     */
    public void insert(Object x, int i){
        // 如果last指向最后一个位置，表示空间已满，不能插入
        if (last == elementData.length-1) return;
        //检查插入位置的合法性
        if (i < 1 || i > last + 2) return;

        for (int j = last; j >= i-1; j--){
            elementData[j + 1] = elementData[j];//从最后一个数开始往后存数
            elementData[i-1] = x; //将x插入
        }
        last++; //last仍指向最后的元素
        return;
    }
删除操作（该代码与教程有点出入，这里的i 是什么，就删除对应下标的值）

    public void delete(int i){
        //检查空表以及删除位置的合法性
        if (i <0 || i > last+1) return;

        for(int j = i; j <= last; j++){
            if (j == last) elementData[last] = null;
            else elementData[j] = elementData[j + 1]; // 从i位置一个一个往前挪
        }
        last--;//last仍指向最后的元素
        return;
    }
1.1.2 线性表的链式存储实现
通过"链"建立数据元素之间的逻辑关系
插入、删除不需要移动数据元素，只需要修改“链”
主要是通过节点，来存储元素，以及指向下一个节点
主要操作的实现

初始化操作：

public class LinkedList<E> {

    Node<E> node;// 链表形式的List含有Node（节点）

    /**
     * 节点拥有两个属性
     * element : 表示该节点的元素
     * nextNode : 指向下一个节点
     * @param <E>
     */
    static class Node<E>{
        E element;//节点的元素
        Node<E> nextNode;//指向下一个节点
        Node(E element, Node<E> nextNode){
            this.element = element;
            this.nextNode = nextNode;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "element=" + element +
                    ", nextNode=" + nextNode +
                    '}';
        }
    }
按位置查找值：通过遍历Node节点，来进行查找

    /**
     * 按位置查找
     * @param k node的位置
     * @return
     */
    Node<E> findKth(int k){
        Node<E> newNode = node;
        int i = 0;
        //不断循环遍历，直到node为0或者i == k
        while (newNode != null && i < k){
            newNode = newNode.nextNode;
            i++;
        }
        return newNode;
    }
按值查找位置 ：

    /**
     * 按值查找节点
     * @param element 元素值
     * @return
     */
    Node<E> find(E element){
        //循环遍历直到找到相同的element
        while (node != null && element != node.element){
            node = node.nextNode;
        }
        return node; //当循环内执行完毕后，如果没找到，此时node就是null了
    }
插入：

    /**
     * 插入元素
     * @param element 要插入的元素
     * @param i 要插入的位置
     * @return 1插入成功，-1插入失败
     */
    int insert(E element, int i){
        //在表头插入
        if(i == 0){
            node = new Node<E>(element, node);
            return 1;
        }
        Node<E> eNode = findKth(i-1);//查找i-1位置的节点
        if (eNode == null) return -1; //如果该位置的并不存在节点，则不能插入
        else {
            Node<E> newNode = new Node<E>(element, eNode.nextNode);//新的节点指向前一个节点的下一个Node
            eNode.nextNode = newNode; //前一个节点指向新的节点
            return 1;
        }
    }
删除操作

    /**
     * 删除操作
     * @param i 需要删除的位置
     * @return 1表示删除成功，-1表示删除失败
     */
    int delete(int i){
        //插入头节点
        if (i == 0) {
         if(node == null) return -1; //node为null，则本身就是个空表，无法删除
         else node = node.nextNode;//将头节点指向下一个节点
            return 1;
        }
        //不是头节点
        Node<E> eNode = findKth(i-1);//获取i-1位置的节点
        if (eNode == null) return -1;//没有该节点，则不能删除
        else if(eNode.nextNode == null) return -1;//即i位置的没有节点，也不能删除
        else {
            eNode.nextNode = eNode.nextNode.nextNode;
            return 1;
        }
    }
从表头添加元素操作（自写，为了方便测试）


    /**
     * 添加方法
     * @param element 需要添加的元素
     * @return
     */
    int add(E element){
        node = new Node<E>(element, node);
        return 1;
    }
测试类

package work;

import org.junit.Test;

public class LinkedListTest {
    @Test
    public void linkedListTest(){
        LinkedList<String> stringLinkedList = new LinkedList<>();
        stringLinkedList.add("1");
        stringLinkedList.add("2");
        stringLinkedList.add("3");
        System.out.println(stringLinkedList.toString());

        stringLinkedList.insert("x", 0);
        System.out.println("插入：" + stringLinkedList.toString());

        stringLinkedList.delete(0);
        System.out.println("删除：" + stringLinkedList.toString());

        LinkedList.Node<String> kth = stringLinkedList.findKth(2);
        System.out.println("获取:" +  kth.toString());

        kth = stringLinkedList.find("2");
        System.out.println("获取:" + kth.toString());



    }

}
测试结果

LinkedList{node=Node{element=3, nextNode=Node{element=2, nextNode=Node{element=1, nextNode=null}}}}
插入：LinkedList{node=Node{element=x, nextNode=Node{element=3, nextNode=Node{element=2, nextNode=Node{element=1, nextNode=null}}}}}
删除：LinkedList{node=Node{element=3, nextNode=Node{element=2, nextNode=Node{element=1, nextNode=null}}}}
获取:Node{element=1, nextNode=null}
获取:Node{element=2, nextNode=Node{element=1, nextNode=null}}
其中，stringLinkedList的详细参数确实形成了链表结构



1.2 堆栈(Stack)：
具有一定操作约束的线性表，只在一端（栈顶，top）做插入、删除

 插入数据：入栈（push）
删除数据：出栈（pop）
后入先出：last in first out (LIFO)
操作：

Stack createStack(int maxSize): 生成空堆栈，其最大长度为maxSize
int isFull(): 判断堆栈S是否已满
void push(E element): 将元素压入堆栈
int isEmpty: 判断堆栈是否为空
E pop(): 删除并返回栈顶元素
package work;

public interface Stack<E> {
    Stack createStack(int maxSize);
    int isFull();
    void push(E element);
    int isEmpty();
    E pop();
}
1.2.1 栈的顺序存储实现
栈的顺序存储结构通常由一个一维数组和一个记录元素位置的变量组成

初始化：

package work;

public class StackImpl<E> implements Stack {
    private Object[] data = {};// 数据存储
    int top = -1;//栈顶元素位置,-1表示空
push操作：


    /**
     * push操作
     * @param element 需要push的值
     */
    @Override
    public void push(Object element) {
        if (top == data.length-1) return; //此时栈满，无法push
        else {
            data[++top] = element;//没满就push
        }
    }
pop操作

    /**
     * pop 操作
     * @return 值
     */
    @SuppressWarnings("unchecked")// 忽略强制类型转换成(E)的警告
    @Override
    public E pop() {
        if (top == -1) return null;//堆栈空
        else return (E)data[top--];// 这个top--用的可以，先return top位置的data后，栈顶位置-1
    }
补充：一个数组实现两个堆栈

原理图：将数组一份为二，分成左右两个栈，左边从左往右存数据，右边从右往左存数据，当top1 == top2时，表示栈满



代码：

package work;

public class TwoStack<E> implements Stack{
    private Object[] data = {};
    private int top1 = -1; // 栈1栈顶
    private int top2 = data.length-1;//栈2栈顶

    /**
     * push操作
     * @param element 要插入的数
     * @param tag 要放入哪个栈
     */
    public void push(E element, int tag){
        if(top1 == top2) return; //相等时。栈满
        if (tag == 1) data[++top1] = element;//tag == 1，放入栈1
        else data[--top2] = element;// tag 不等于1，放入栈2
    }

    /**
     * pop操作
     * @param element 要插入的数
     * @param tag 要放入哪个栈
     * @return
     */
    @SuppressWarnings("unchecked")
    public E pop(E element, int tag){
        if (tag == 1){
            if (top1 == -1) return null;//等于-1，空栈，无法pop
            else return (E)data[top1--];//返回值，并top -1
        }
        else{
            if (top2 == data.length-1) return null; //空栈，无法pop
            else return (E)data[top2++];//返回值，并top + 1
        }

    }
1.2.2 堆栈的链式存储实现
栈的链式存储结构实际上是单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。

栈顶Top指向链表的指向第一个节点（为什么不能指向最后一个节点，因为在pop操作时，你无法获取到前一个节点，自然无法删除当前节点）

初始化操作：topNode仅仅是栈头节点，只用来指向第一个节点（即用来指向栈顶）

package work;

public class LinkedStack<E> implements Stack{
    private Node<E> topNode;//栈头节点，初始值只用来指向下一个节点

    public LinkedStack() {
        this.topNode = new Node<>();
    }

    static class Node<E>{
        E element;
        Node<E> nextNode;
        Node(){};//默认构造函数
        Node(E element, Node<E> nextNode){
            this.element = element;
            this.nextNode = nextNode;
        }
    }
判空操作

    @Override
    public boolean isEmpty() {
        //栈头节点没有指向节点，说明是空栈
        return topNode.nextNode == null;
    }
push操作

    /**
     * push操作
     * @param element
     */
    @Override
    @SuppressWarnings("unchecked")
    public void push(Object element) {
        topNode.nextNode = new Node<>((E) element, topNode.nextNode);//将栈头指向的node 赋值给新node，栈顶指向新node

    }
pop操作

    /**
     * pop 操作
     * @return 返回元素
     */
    @Override
    public E pop() {
        if(this.isEmpty()) return null;// 栈空
        else {
            Node<E> nextNode = topNode.nextNode;//获取第一个节点
            topNode.nextNode = nextNode.nextNode;//栈顶节点指向第二个节点
            return (E)nextNode.element;//返回第一个节点的值
        }
    }
1.3 队列（Queue）
具有一定操作约束的线性表，只能在一端插入，在另一端删除。
数据插入：入队列（addQ）
数据删除：出队列（deleteQ）
先仅限出：FIFO
操作：

Queue createQueue(): 生成空队列
boolean isFullQ(): 队列是否已满
void addQ(E element): 插入元素到队列
boolean isEmptyQ(): 是否为空
E deleteQ(): 将队头数据从队列中删除并返回
public interface Queue<E> {
    boolean isFullQ();
    void addQ(E element);
    boolean isEmpty();
    E deleteQ();
}
1.3.1 队列的顺序存储实现
结构：由一个一维数组和一个记录队列头元素位置的变量front和一个记录队尾元素位置的变量rear组成

初始化

public class QueueImpl<E> implements Queue<E> {
    private Object[] data;
    private int front = -1;//头元素位置，初始-1，删除时+1
    private int rear = -1;//队尾元素位置，初始-1，添加时+1
addQ操作

    @Override
    @SuppressWarnings("unchecked")
    public void addQ(Object element) {
        int remainder = (rear + 1) % data.length;//+1求余，可以进行循环操作数组
        if( remainder == front) return; //当+1后恰好等于front,则表示队列满
        rear = remainder;//改变rear的值（其实已经执行了+1操作）
        data[rear] = (E)element;
    }
deleteQ操作

 @Override
    @SuppressWarnings("unchecked")
    public E deleteQ() {
        if(front == rear) return null; //相等时队列为空
        else {
            front = (front+1) % data.length;
            return (E)data[front];
        }
    }
1.3.2 队列的链式存储实现
front和rear只能指向链表头（链表为单向，单项的链表用链表尾时不可能做删除操作的【取不到前一个节点】）

初始化：两个node结构，Node形成链，QNode形成队列的节点结构，指向队尾和队头两个节点。

public class LinkedQueue<E> implements Queue {
    private QNode qNode;

    static class Node<E>{
        E element;
        Node nextNode;//指向节点
    }

    static class QNode{
        Node rear;//指向队尾节点
        Node front;//指向队头节点
    }
deleteQ操作

  @Override
    @SuppressWarnings("unchecked")
    public Object deleteQ() {
        Node front = qNode.front;//队列头指向的节点
        Node rear = qNode.rear;//队列尾指向的节点
        E element = null;//节点元素
        if (front == null) return null; //如果队列头节点是空的，那整个队列肯定都是空的
        if (front == rear) front = rear = null;//头尾相等，表示只有一个节点，删除后为null了
        else {
            element = (E)front.element;//把节点的值赋值给element
            front = front.nextNode;// 头节点指向下一个节点
        }
        return element;
    }
2 树
2.1 查找（Searching）：
根据给定关键字K，从集合R中找出关键字和K相同的记录。
静态查找：集合中记录固定，没有插入和删除操作，只有查找
动态查找：集合中记录是动态变化的，除查找，还可能发生插入和删除
2.1.1 静态查找：
方法1：顺序查找 (T(n) = O(n))

package work;

public class LNode<E> {
    E[] elementData;

    /**
     * 
     * @param element
     * @return element的位置
     */
    public int sequentialSearch(E element){
        int i;
        for (i = elementData.length;i > 0 && elementData[i] != element; i-- );
        return i;
    }
   
}
技巧，建立哨兵

以查找数组为例。建立哨兵后，for循环减少了一个判断条件。

注：elementData 数组必须要从1开始存储

 /**
     *
     * @param element
     * @return element的位置,0 则未找到
     */
    public int sequentialSearch2(E element){
        int i;
        elementData[0] = element;//建立哨兵
        for (i = elementData.length;i > 0 && elementData[i] != element; i-- );//即使没有找到，0的位置肯定是element（哨兵的值就是这个）
        return i; //i如果是0就是没找到
    }
方法2：二分查找（Binary Search）

T（n） = O(logN), 数组需要按顺序存储。

    int[] numbers;

    public int binarySearch(int number){
        int left = 0; //设置左边界
        int right = elementData.length-1;//设置有边界
        int mid;//中心
        while (left <= right){
            mid = (left + right)/2;
            if (number < numbers[mid]) right = mid -1; //调整右边界
            else if(number > numbers[mid]) left = mid + 1;//调整左边界
            else return mid;
        }
        return -1;//-1表示没找到
    }
很明显，方法2 在查找速度上具有更好的性能。

其实，假设有11个数，计算每次mid的值，可以得到如下图，中间数字代表mid的值，往左表示值小于mid，往右表示值大于mid

如当element < elementData[5]时，接下来要比较的就是(0+5-1)/2 = 2,也就是elementData[2]这个分支

如此类推成树状的结构。



2.2 树（tree）的定义: 
n(n>=0)个节点构成的有限集合，对于任一棵非空树（n > 0）,它具备以下性质

树中有一个根(Root)的特殊节点
其余节点可分为m（m>0）个互不相交的有限集T1，T2... Tm,其中每个集合本身也是一棵树，称为原来树的“子树”
树的基本术语

节点的度（degree）：节点的子树个数
树的度：树的所有节点中最大的度数
叶节点（leaf）：度为0的节点
父节点（parent）
子节点（child）
兄弟节点（sibling）
路径和路径长度：从节点n1到nk的路径为一个节点序列n1,n2....,nk。ni 是ni+1的父节点。路径所包含边的个数为路径的长度
祖先节点（Ancestor）
子孙节点（Descendant）
节点的层次(level):规定根节点在1曾，其他任一节点的层数是其父节点的层数+1
树的深度（Depth）：树中所有节点中的最大层次是树的深度
树的表示

儿子兄弟表示法：firstChild指向第一个子节点，nextSibling指向下一个兄弟节点


二叉树

一个又穷的节点集合，可以为空。
不为空，则由根节点和称其左子树和右子树的两个不相交的二叉树组成。
二叉树的五种基本形态


二叉树的子树有左右之分
特殊二叉树

斜二叉树




完美二叉树（满二叉树）
除了最后一层，其他节点都是2个子节点



完全二叉树：
除去最后一层就是个完美二叉树

最后一层编号与完美二叉树对应，如图，错图9的位置应该是10



二叉树的几个重要性质

一个二叉树的第i曾最大节点数为2^i-1 ,i>= 1
深度为k的二叉树有最大节点数总数为：2^k-1 ,k>= 1
对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么，no = n2 +1 


二叉树抽象定义

类名:Tree

数据对象集：一个有穷的节点集合，若不为空，则由根节点和其左、右二叉子树组成

操作集：

Boolean isEmpty(): 判断是否为空
void traversal(): 遍历，按某顺序访问每个节点
常用遍历方法

void preOrderTravelsal(): 先序，根、左子树、右子树
void inOrderTraversal(): 中序，左子树、根、右子树
void postOrderTraversal(): 后序，左子树、右子树、根
void levelOrderTraversal(): 层次遍历，从上到下，从左到右
二叉树遍历的核心问题：二维结构的线性化

实际为把二维结构编程线性结构的过程
需要一个存储结构保存暂时不访问的节点
存储结构：堆栈、队列
二叉树的顺序存储结构

完全二叉树：从上之下，从左到右顺序存储n个节点的完全二叉树的节点父子关系。[使用数组实现非常方便]

非根节点（序号i > 1）的父节点的需要事[i/2]
节点(序号i)的左孩子节点的序号是2i
节点(序号i)的右孩子节点的序号是2i+1


其他二叉树也可以用数组实现，但是会造成空间浪费。而完全二叉树是很适合数组实现的。可以看到，黑色圆就是浪费的空间。



二叉树的链式存储

element: 节点的元素
left:指向左子树
right：指向右子树
package work;

public class BinaryTreeImpl<E> implements BinaryTree{
    TreeBinNode treeBinNode;// 节点
    static class TreeBinNode<E>{
        E element;//元素
        TreeBinNode<E> left;//左子树
        TreeBinNode<E> right;//右子树
        public TreeBinNode(E element, TreeBinNode left, TreeBinNode right) {
            this.element = element;
            this.left = left;
            this.right = right;
        }
    }
二叉树的遍历

先序遍历（根节点顺序> 左子树>右子树顺序）,也就是说随便取一个节点，它的执行顺序肯定是最大的，左子树的执行顺序肯定要先于右子树



与教程方法不同，因为C是面向过程。而java是面向对象的，多创建了一个私有的有参方法，用于将节点传入并递归，而公开方法内部调用有参方法。这样做，可以直接通过进行递归而不需要传入任何节点。

    /**
     * 先序遍历
     * 调用了私有方法，目的是把本身的TreeBinNode节点传递进去，方便递归
     */
    @Override
    public void preOrderTraversal() {
        preOrderTraversal(treeBinNode);
    }

    /**
     * 先序遍历私有方法
     * 递归每一个treeBinNode,来访问树的每个节点
     * @param treeBinNode 需要遍历的节点
     *
     */
    private void preOrderTraversal(TreeBinNode treeBinNode) {
        if (treeBinNode != null){
            System.out.println(treeBinNode.element);
            preOrderTraversal(treeBinNode.left);
            preOrderTraversal(treeBinNode.right);
        }       
    }
以先序遍历为例，说明访问节点的时机。

事实上，每次调使用preOrderTraversal(TreeBinNode treeBinNode)[后面用p()方法描述],我们有3次机会访问到treeBinNode节点。

第一次机会，就是一开始进入p()方法时，我们可以访问treeBinNode,此时访问就是先序

第二次机会，就是p(treeBinNode.left) -> p(treeBinNode) ,左子树递归完后，回到p()方法，此时访问就是中序

第三次机会，就是p(treeBinNode.right) -> p(treeBinNode) ,右子树递归完后，回到p()方法，此时访问就是后序



中序遍历（ 左子树>根节点顺序>右子树顺序）





    /**
     * 中序遍历
     */
    @Override
    public void inOrderTraversal() {
        inOrderTraversal(treeBinNode);

    }

    private void inOrderTraversal(TreeBinNode treeBinNode) {
        if(treeBinNode != null){
            preOrderTraversal(treeBinNode.left);
            System.out.println(treeBinNode.element);
            preOrderTraversal(treeBinNode.right);
        }
    }
后续遍历（ 左子树>右子树顺序>根节点顺序）



    /**
     * 后续遍历
     */
    @Override
    public void postOrderTraversal() {
        postOrderTraversal(treeBinNode);
    }
    public void postOrderTraversal(TreeBinNode treeBinNode) {
        if(treeBinNode != null){
            preOrderTraversal(treeBinNode.left);
            preOrderTraversal(treeBinNode.right);
            System.out.println(treeBinNode.element);
        }
    }
二叉树及的非递归遍历

以中序遍历为例

遇到一个节点，就把它push到栈中，并去遍历它的左子树
左子树遍历完后，弹出栈顶节点，并访问它
然后按其右指针再去遍历该节点的右子树
    /**
     * 中序遍历非递归遍历算法
     * @param node
     */
    private void inOrderTraversal(TreeBinNode node){
        LinkedStack<TreeBinNode> eLinkedStack = new LinkedStack<>();//创建堆栈
        while (node != null || !eLinkedStack.isEmpty()){
            while (node != null){ //一直向左并沿途将节点push到栈中
                eLinkedStack.push(node);
                node = node.left;
            }
            if (!eLinkedStack.isEmpty()){
                node = eLinkedStack.pop();//节点弹出堆栈
                System.out.println(node.element);//访问节点操作
                node = node.right;
            }
        }
    }
解析：

假设有如图所示的树



它的具体实现步骤如下，可以看出它会先将所有的左子树节点压入栈中，然后弹出节点，访问后遍历右节点，将右节点压入栈中。



那么接下来实现先序算法就简单了（先序是第一次碰到节点的时候访问，第一次其实就是在push的时候），所以，只要改动如下，就可以实现先序遍历。【注意访问节点操作移动到了push后面】

  /**
     * 先序遍历
     * @param node
     */
    private void preOrderTraversal(TreeBinNode node){
        LinkedStack<TreeBinNode> eLinkedStack = new LinkedStack<>();//创建堆栈
        while (node != null || !eLinkedStack.isEmpty()){
            while (node != null){ //一直向左并沿途将节点push到栈中
                eLinkedStack.push(node);
                System.out.println(node.element);//访问节点操作
                node = node.left;
            }
            if (!eLinkedStack.isEmpty()){
                node = eLinkedStack.pop();//节点弹出堆栈
                node = node.right;
            }
        }
    }
后续遍历？

思路：pop节点后，会再拿到right节点。根据后续遍历的特点，根节点为最后遍历。即：

right 不为null的话，应该要把当前节点在push回去，压入right
如果是第二次POP出这个节点的话，不会再push进去，而是直接访问了。


层序遍历

根节点入队
从队列中取出一个数
访问该元素所指的节点
若该元素所指节点的左右子节点非空，就将子节点按顺序入队
图解原理



代码


    /**
     * 层序遍历
     */
    @Override
    public void levelOrderTraversal() {
        TreeBinNode newTreeBinNode;
        QueueImpl<TreeBinNode> queue = new QueueImpl<>();//创建并初始化队列
        queue.addQ(treeBinNode);//放入根节点
        while (!queue.isEmpty()){
            newTreeBinNode = queue.deleteQ();
            System.out.println(newTreeBinNode.element);//访问该节点
            //添加其左右子树
            if (newTreeBinNode.left != null) queue.addQ(newTreeBinNode.left);
            if (newTreeBinNode.right != null) queue.addQ(newTreeBinNode.right);
        }

    }
思考：如何使用堆栈方式实现层序遍历？？？

二叉搜索树（BST, Binary Search Tree）

又称二叉排序树或二叉查找树
查找操作取决于树的高度
可以为空；如果不为空，需要满足以下性质
非空左子树的所有键值小于其根节点的键值
非空右子树的所有键值大于其根节点的键值
左右子树都是二叉搜索树


二叉搜索树操作的特别函数

BinaryTree find(E element):从二叉搜索树中查找元素，返回其所在的节点地址
BinaryTree findMin(): 从二叉搜索树中查找并返回最小元素所在节点的地址
BinaryTree findMax(): 从二叉搜索树中查找并返回最大元素所在节点的地址
void insert(E element):插入元素
void delete(E element): 删除元素
find操作

查找从根节点开始，如果树为空，返回null
若非空，则根节点关键字和元素比较，并进行不同的处理
元素小于根节点，只需在左子树中继续搜索
元素大于根节点，只需在右子树中继续搜索
相等，搜索完毕，返回此节点的位置
    /**
     * 查找操作
     * @param element
     * @return 当前元素所在节点
     */
    public TreeBinNode find(int element) {
        return find(element, treeBinNode);
    }

    /**
     * 私有方法，将节点传入，便于递归
     * 使用的目的只有一个，将默认的treeBinNode传入到方法中
     * @param element
     * @param treeBinNode
     * @return
     */
    private TreeBinNode find(int element,TreeBinNode treeBinNode) {
        if (treeBinNode == null) return null;//查找失败
        if (element > treeBinNode.element) return  this.find(element,treeBinNode.right); //在右子树中继续查找
        else if (element < treeBinNode.element) return this.find(element, treeBinNode.left);// 在左子树中继续查找
        else return treeBinNode; //等于情况， 返回该节点
    }
[注：使用的递归位置都在return 后面，这种递归方式称为尾递归。]

由于非递归函数的执行效率高，所以可将“尾递归”函数改为迭代函数。


    /**
     * 循环方式查找操作
     * @param element
     * @return 当前元素所在节点
     */
    public TreeBinNode iterFind(int element) {
        return find(element, treeBinNode);
    }

    /**
     * 私有方法，将节点传入，便于递归
     * 使用的目的只有一个，将默认的treeBinNode传入到方法中
     * @param element
     * @param node
     * @return
     */
    private TreeBinNode iterFind(int element,TreeBinNode node) {
        while (node != null){
            if (element > node.element) node = node.right; //在右子树中继续查找
            else if (element < node.element) node = node.left; // 在左子树中继续查找
            else return node;//等于情况， 返回该节点
        }
        return null;//查找失败
    }
finMin操作（尾递归方式）

    /**
     * 查找最小值,尾递归方式
     * @return
     */
    public TreeBinNode findMin() {
        return findMin(treeBinNode);
    }
    private TreeBinNode findMin(TreeBinNode node) {
        if (node == null) return null;//空节点，返回null
        else if (node.left == null) return node;//如果左为空，则当前节点就是最小值了，直接返回
        else return findMin(node.left);// 继续在左子树中查找
    }
findMax操作(循环方式)

    /**
     * 查找最大值,循环方式
     * @return
     */
    public TreeBinNode findMax() {
        return findMax(treeBinNode);
    }
    private TreeBinNode findMax(TreeBinNode node) {
        if (node != null){
            while (node.right != null) node = node.right; //查找到最右叶节点为止
        }
        return node;
    }
[注：因为两者方式相近，所以findMin的循环方式和findMax的尾递归方式可以互相参考]

insert操作

分析：关键是找到元素应该插入的位置，可以借鉴find操作。 通过元素不断比较大小，来找到合适的位置。然后新建一个node来将元素保存到该节点中，返回后的node将会赋值给node的左或右子树。

    /**
     * 删除元素
     * @param element
     */
    public void delete(int element) {
        treeBinNode = delete(element, treeBinNode);
    }

    public TreeBinNode delete(int element, TreeBinNode node) {
        if (node == null) return null; // node为空
        else if (element < node.element) node.left = delete(element, node.left);//左子树递归删除
        else if (element > node.element) node.right = delete(element, node.right);//右子树删除节点
        else {
            if (node.left != null && node.right != null){//被删除节点有两个子节点
                //在右子树中找最小的元素填充删除节点
                TreeBinNode min = findMin(node.right);
                node.element = min.element;
                node.right = delete(node.element, node.right);
            }else{//被删除节点有一个或无子节点
                if(node.left != null) treeBinNode = node.left; //有左孩子或无子节点
                else if (node.right != null) treeBinNode = node.right;//有右孩子或无子节点
            }
        }
        return node;
    }
}
delete操作

情况一：删除的节点只有一个孩子节点。如图，要删除33节点，只需要让它的父节点指向它的子节点即可。



情况二：删除的节点有左右两个子节点。此情况比较复杂

解决思路为：简单化操作，将情况二转换成情况一。
具体：用另一个节点替代被删除的节点。该节点可以是右子树的最小元素或者左子树的最大元素。
原理：因为右子树的最小元素【一定在右子树最左边】、左子树的最大元素【一定在左子树最后边】一定没有两个孩子节点（相当与转换成情况一）
图片分析：右子树的最小值，肯定也是大于左子树，所以完全没问题。而且最小值的替代删除节点后，右子树也一定没问题（毕竟最小值）



同理，左子树的最大值，肯定大于删除节点的左子树，但肯定小于删除节点右子树



    /**
     * 删除元素
     * @param element
     */
    public void delete(int element) {
        delete(element, treeBinNode);
    }

    public TreeBinNode delete(int element, TreeBinNode node) {
        if (node == null) return null; // node为空
        else if (element < node.element) node.left = delete(element, node.left);//左子树递归删除
        else if (element > node.element) node.right = delete(element, node.right);//右子树删除节点
        else {
            if (node.left != null && node.right != null){//被删除节点有两个子节点
                //在右子树中找最小的元素填充删除节点
                TreeBinNode min = findMin(node.right);
                node.element = min.element;
                node.right = delete(node.element, node.right);
            }else{//被删除节点有一个或无子节点
                if(node.left != null) node = node.right; //有右孩子或无子节点
                else if (node.right != null) node = node.left;//有左孩子或无子节点
            }
        }
        return node;
    }
}
平衡二叉树（Balanced Binary Tree，AVL树）

首先了解：搜索树不同的插入次序，将导致不同的深度和平均查找长度ASL。而ASL就是衡量一个搜索树效率的指标。

排序的不同，其ASL也不同。不难发现，对于B，查找一个元素，平均只需要3次即可，效率最高。



什么是平衡二叉树？

空树，或任一结点左右子树高度差的绝对值不超过1，即| BF(T)| <= 1。
BF：平衡因子（Balance Factor,简称BF），计算公式为BF(T) = hl - hr。（hl,hr为T的左右子树高度）
平衡二叉树：T(n) = O(log2n)
如下图，这两个并不是平衡二叉树



平衡二叉树实现

 private static class AVLNode<T>{
        T element; //结点数据
        AVLNode<T> leftNode;// 左子树
        AVLNode<T> rightNode;// 右子树
        private int height; //高

        AVLNode(T element){
            this(element, null, null);
        }
        AVLNode(T element,  AVLNode<T> leftNode, AVLNode<T> rightNode){
            this.element = element;
            this.leftNode = leftNode;
            this.rightNode = rightNode;
        }

计算平衡二叉树的高

        /**
         * 返回结点高，null时-1。
         * @param node
         * @return
         */
        private int height(AVLNode<T> node){
            return node == null ? -1 : node.height;
        }
平衡二叉树的调整

当插入一个结点后，可能破环二叉树的平衡。一共有四种情况，并针对这四种情况，有不同的调整方式。

RR旋转：新插入的结点位于被破坏结点的右子树的右子树上



或



旋转方式：【图1描述了旋转的方式，图2描述具体的结点指向】



代码:


        /**
         * RR型适用
         * 左旋(顺时针旋转)
         * @param parent 被破坏的结点
         * @return
         */
        private AVLNode<T> rotateWithRightChild(AVLNode<T> parent){
            AVLNode<T> child = parent.rightNode;
            parent.rightNode = child.leftNode;//parent右子树指向child左子树
            child.leftNode = parent;//child左子树子向parent
//            重新计算高度
            parent.height = Math.max(height(parent.leftNode), height(parent.rightNode)) + 1;
            child.height = Math.max(parent.height, height(child.rightNode)) + 1;
            return child;
        }
LL旋转（右旋，与RR相似）：新插入的结点位于被破坏结点的左子树的左子树上



旋转详情：



        /**
         * LL型适用
         * 右旋(顺时针旋转)
         * @param parent 被破坏的结点
         * @return
         */
        private AVLNode<T> rotateWithLeftChild(AVLNode<T> parent){
            AVLNode<T> child = parent.leftNode;
            parent.leftNode = child.rightNode; //parent左子树指向child右子树
            child.rightNode = parent; //child右子树子向parent
//            重新计算高度
            parent.height = Math.max(height(parent.leftNode), height(parent.rightNode)) + 1;
            child.height = Math.max(height(child.leftNode), parent.height) + 1;
            return child;
        }
LR旋转：新插入的结点位于被破坏结点的左子树的右子树上



旋转详情



        /**
         * LR型适用
         * 双旋转
         * @param node 被破坏的结点
         * @return
         */
        private AVLNode<T> doubleWithLeftChild(AVLNode<T> node){
            node.leftNode = rotateWithRightChild(node.leftNode);
            return rotateWithLeftChild(node);
        }
RL旋转（与LR相似：新插入的结点位于被破坏结点的右子树的左子树上）



旋转详情




        /**
         * RL型适用
         * 双旋转
         * @param node 被破坏的结点
         * @return
         */
        private AVLNode<T> doubleWithRightChild(AVLNode<T> node){
            node.leftNode = rotateWithLeftChild(node.leftNode);
            return rotateWithRightChild(node);
        }
AVL树的插入操作

结点为空时需要创建一个新的结点
结点不为空时，根据插入元素的值来寻找何时的插入位置
插入完毕后，如果平衡遭到破坏，还需要进行平衡调整
    /**
         * 插入操作
         * @param element 插入的元素
         * @param node 
         * @return
         */
        private AVLNode<T> insert(T element, AVLNode<T> node){
//            node为null，则新建node，并插入element
            if (node == null) return new AVLNode<T>(element, null, null);
//            compare先不管怎么实现，其功能是比较插入元素和node元素之间的大小
            int compareResult = compare(element, node.element);
            //插入元素小于node元素时
            if (compareResult < 0 ){
                node.leftNode = insert(element, node.leftNode);//递归，小于情况要插入左子树
//                平衡调整
                if (height(node.leftNode) - height(node.rightNode) == 2){
                    //比较插入值与node左子树的元素值大小，如果小于，那插入值肯定位于node元素左子树的左子树的某个子树的结点上，需要进行LL旋转
                    if (compare(element, node.leftNode.element) < 0) node = rotateWithLeftChild(node);
                    //如果大于（不可能等于，等于的话不会插入值，也就不会破坏平衡），那插入值肯定位于node元素左子树的右子树的某个子树的结点上，需要进行LR旋转
                    else  node = doubleWithLeftChild(node);
                }
            }
            //插入元素大于node元素时
            else if(compareResult > 0){
                node.rightNode = insert(element, node.rightNode);//递归，大于情况要插入右子树
//              平衡调整
                if (height(node.rightNode) - height(node.leftNode) == 2){
                    //比较插入值与node右子树的元素值大小，如果大于，那插入值肯定位于node元素右子树的右子树的某个子树的结点上，需要进行RR旋转
                    if (compare(element, node.rightNode.element) > 0 ) node = rotateWithRightChild(node);
                    //如果小于（不可能等于，等于的话不会插入值，也就不会破坏平衡），那插入值肯定位于node元素右子树的左子树的某个子树的结点上，需要进行RL旋转
                    else node = doubleWithRightChild(node);
                }
            }
            else ;//等于时不用做任何事
//            更新高度
            node.height = Math.max(height(node.leftNode), height(node.rightNode)) + 1;
            return node;
        }
AVL树的删除操作

2.3 堆(heap)
优先队列(priority queue)： 特殊的“队列”，取出元素的顺序是按照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。

堆的两个特性:

结构性：用数组表示的完全二叉树

有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）

最大堆（MaxHeap）,也称“大顶堆”，最大值
最小堆（MinHeap），也称“小顶堆”，最小值
堆的抽象数据类型描述

类型名称：堆(Heap)

数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值

操作集：

MaxHeap constructor(int maxSize): 构造函数

boolean isFull(): 判断最堆是否已满

boolean isEmpty(): 判断堆是否为空

void insert(E element): 讲元素element插入堆中

E deleteMax(): 返回堆中最大元素（高优先级）

public interface Heap<E> {
    boolean isFull();
    boolean isEmpty();
    void insert(E element);
    E deleteMax();
}
实例MaxHeap(最大堆)

public class MaxHeap<E> implements Heap {
    private E[] elements; //存储堆元素的数组
    private int size; // 堆的当前元素个数
    private int capacity;// 堆的最大容量
//  private E element; 定义的哨兵，该值可视情况定义，必须是整个数组中最大的
constructor操作

数组0位置为哨兵，数据插入从1号位置开始

    public MaxHeap(int maxSize) {
        this.elements = (E[])new Object[maxSize + 1];
        this.size = 0;
        this.capacity = maxSize;
//        this.elements[0] = element; 如果有哨兵，则哨兵的位置在0号位
    }
isFull操作

当元素的个数等于容量时，表示堆已满

    @Override
    public boolean isFull() {
        return this.size == this.capacity;
    }
isEmpty操作

元素个数为0表示堆为空

    @Override
    public boolean isEmpty() {
        return this.size == 0;
    }
insert操作

判断堆是否已满
未满，size+1 的值暂定为元素要插入的位置
size增加1
完全二叉树，i/2 得到的值就是该结点的父结点的位置。
保证最大堆父结点一定大于子结点，比较结点值与父结点的大小，来决定是否需要挪动位置
    @Override
    public void insert(Object element) {
        if (isFull()){
            return;//堆已经满,无法插入
        }
       int i = ++size;// i指向堆中的最后一个元素位置,++时插入后size要加一
        //不断比较元素和父结点的大小
        //i/2为父结点的位置
        //如果元素大于父结点，则将父结点的值赋值到i位置,再将i指向父结点的位置,以保证父结点永远是最大值
        //如果i等于1，则不会进入for循环，直接将值赋值到数组中
        for (;compare(elements[i/2], element) < 0 && i > 1; i /= 2) elements[i]= elements[i/2];
        //在有哨兵的情况下，可以省略for循环的条件i > 1,因为0位置肯定最大
//        for (;compare(elements[i/2], element) < 0 ; i /= 2) elements[i]= elements[i/2];
        elements[i] = (E)element; //将element插入
    }
deleteMax操作

取出根元素操作
取最后一个元素暂定补重到根元素的位置，为保持堆的特性，通过由根开始的向下过滤（保证父结点最大）
size减一
  public E deleteMax() {
        int parent;//记录父结点的位置
        int child;//记录子结点的位置

        if (isEmpty()) return null; //判空，则无法删除

        E maxElement = elements[1];//取出根结点
        E lastElement = elements[size--];//取最后一个元素，取出后堆size 减一

        //具体操作，用最大堆的最后一个元素从根元素开始向下比较左右结点的大小
        //如果元素大于左右儿子，则该位置就是最后一个元素的放至位置
        //如果元素小于其左右儿子中的最大值，则继续向较大子结点的下层进行比较，直到合适的位置
        for(parent = 1; parent*2 <= size; ){
            child = parent * 2;//相当于左子结点的位置
            //比较parent的左右儿子，找到比较大的儿子位置
            if (child != size && compare(elements[child], elements[child +1]) < 0){
                child++;
            }
            //如果最后一个元素要比child位置的值大，那说明不需要继续过滤下去了，否则，继续向下过滤
            if (compare(lastElement, elements[child]) >= 0) break;//找到合适位置
            else elements[parent] = elements[child];//向下
            parent = child;
        }
        elements[parent] = lastElement;
        return maxElement;
    }
最大堆的建立

将已经存在的N个元素，按最大堆的要求存放在一个一维数组中。

方法一：通过插入操作，一个个将N个元素插入到初始为空的堆中，时间复杂度为(NlogN)

方法二：

将N个元素按顺序存入，先满足完全二叉树的特性
调整各结点位置，以满足最大堆的有序特性
复杂度为O（N）
通过从最后一个子结点的父结点开始到根结点，从下而上，从右到左将各个子树调成堆

    /**
     * 调整根单个根结点
     * 类似于deleteMax操作，但必须保证该结点的左右子结点均为堆
     * @param postion 根结点位置
     */
    private void percDown(int postion){
        int parent, child;
        E element = elements[postion];
        for (parent = postion; parent * 2 <= size;){
            child = parent * 2;
            if (child != size && compare(elements[child], elements[child + 1]) < 0) child++;
            if (compare(element, elements[child]) >= 0) break;
            else elements[parent] = elements[child];
            parent = child;
        }
        elements[parent] = element;
    }

    /**
     * 调整整个数组操作，从最后一个结点的父结点开似乎
     */
    private void buildHeap(){
        int i;
        //size/2 为最后一个元素的父结点
        //从父结点开始调整，直到根结点为1，都调成堆元素
        for (i = size/2; i > 0; i--) percDown(i);
    }
哈夫曼树（Huffman Tree）

带权路径长度（WPL）：设二叉树有n个叶结点，每个叶结点带有权值Wk,从根结点到每个叶结点的长度为lk,则每个叶结点的带权路径长度之和就是WPL。（权值相当于每个结点的频率）

哈夫曼树（最优二叉树）：WPL最小的二叉树

例：有五个叶结点，它的权值为{1,2,3,4,5},根据权值序列可以构造不同的多个二叉树



哈夫曼树的构造

方式:每次把权值最小的两棵二叉树合并，还是以权值{1,2,3,4,5}的5个叶结点为例



public class HuffmanTree<T> {
    private TreeNode rootNode;
    private static class TreeNode<T>{
        int weight;//权重
        TreeNode<T> leftNode;
        TreeNode<T> rightNode;
    }

    /**
     * 构造哈夫曼树
     * @param minHeap 需要提供一个最小堆，方便取最小值
     */
    public HuffmanTree(MinHeap minHeap) {
        int i;
        TreeNode<T> treeNode;
        minHeap.buildHeap();//调整为最小堆
        //进行循环后，minHeap的结点构造满足哈夫曼树
        for (i = 1; i < minHeap.getSize(); i++){ //做size-1次合并
            treeNode = new TreeNode<T>();
            treeNode.leftNode = minHeap.deleteMin();//取最小堆中最小的结点，作为treeNode的左子结点
            treeNode.rightNode = minHeap.deleteMin();//取最小堆中的最小的结点，作为treeNode的右子结点
            treeNode.weight = treeNode.leftNode.weight + treeNode.rightNode.weight;//重新计算权值
            minHeap.insert(treeNode);//将新的结点插入到最小堆
        }
        treeNode = minHeap.deleteMin();//取出跟结点
        return treeNode;
    }
}
哈夫曼树的特点：

没有度为1的结点（因为是两两合并成一个结点，所以要么0，要么2）
n个叶子结点的哈夫曼树有2n-1个结点
哈夫曼树的任意非叶结点的左右子树交换后仍然是哈夫曼树
同一组权值，存在不同结构的两颗哈夫曼树，但WPL值是相同的，如下图


哈夫曼编码

解决的问题：给定的字符串，对其字符进行彪马，使得该字符串的编码存储空间最少。

例: 有一段文本，包含58个字符，由7个字符构成：a,e, i,s,t, sp(空格),nl(换行)。7个字符出现的次数不同(即权值不同)，对该7个字符进行编码，使得编码空间最少。

[分析]

用等长ASCII编码(每个字符占1字节即8位)： 则，需要58x8 = 464位。
用等长3位编码(因为一共就7个字符，无需8位这么多)：则，需要58x3 = 174位。
不等长编码: 频率高的字符用的编码短一些，频率低的字符编码长一些。
不等长编码：

需要避免二义性: 任何字符的编码都不是另一个字符编码的前缀码（prefix code）。

如a: 1, e: 0, s: 10， 那么1010,可以解释aes、sae、ss，即出现了二义性。因为a的编码为s的前缀码。

解决方式：二叉树用于编码

左右分支：0、1
字符只在叶结点上（在叶结点上保证编码不会成为另一个字符的前缀）


而这种不等长编码构造的二叉树，就是哈夫曼树。

所以，例中的编码方式如下图





集合的表示

集合运算：交、并、补、差、判定元素是属于某一集合。



并查集:即合并集合，查询某元素属于什么集合

集合存储实现：使用树结构表示集合，树的每个结点代表一个集合元素

并操作，只要将一个集合的根结点指向另一个集合的根结点
查询某元素属于什么集合：向上查找根结点即可（根必须唯一）


数组存储实现

Type类为数组中的元素，它主要有数据和一个指向父元素的坐标组成

public class SeyType <E>{
    private Type<E>[] types;// 数组

    //数组元素类
    private class Type<E> {
        private E data;//数据
        private int parent;//父元素坐标

        public int getParent() {
            return parent;
        }

        public E getData() {
            return data;
        }

        public void setData(E data) {
            this.data = data;
        }

        public void setParent(int parent) {
            this.parent = parent;
        }
    }
parent 负数表示根结点



查询某元素属于什么集合：

先查找元素的位置
再通过元素位置查找出它指向的根结点

    /**
     * 查询某个元素所在的集合（用根结点表示）
     * @param element 元素
     * @return
     */
    public int find(E element){
        int i;
        for (i = 0; i < types.length && types[i].equals(element); i++);//遍历，找打element的位置
        if (i >= types.length) return -1;//超出范围，即没找到
        for (; types[i].getParent() >= 0; i = types[i].getParent());//不断向上找父元素的坐标
        return i;//返回树根结点在数组中的下标
    }
并操作

分别找到两个元素所在的根结点
如果两个根不同，则将其中一个根的parent指向两一个根的parent,实现合并
    /**
     * 集合并元素
     * 找到两个元素的根
     * 根不同，将其中一个根指向另一个根
     * @param element
     * @param otherElement
     */
    public void union(E element, E otherElement){
        int root;
        int otherRoot;
        root = find(element);//找到第一个元素的根
        otherRoot = find(otherElement);//找到第二个元素的根
        if (root != otherRoot) types[root].parent = otherRoot;
    }
改善合并后的查找性能

采用小的集合合并到大的集合
利用parent的值表示集合个数，从而更容易分别集合大小




3 图（Graph）
【番外：六度空间理论  https://baike.baidu.com/item/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%E7%90%86%E8%AE%BA/6494090?fr=aladdin】

什么是图？

表示“多对多”的关系
包含：
一组顶点：通常用V(Vertex)表示顶点集合
一组边：通常用E（Edge）表示边的集合[边是由顶点对]


抽象数据类型定义

类型名称：图（Graph）

数据对象集：G(V, E),由一个非空有限顶点集合V和一个有限边集合E组成

操作集：

Graph constructor(): 构造函数

Graph insertVertex(Vertex v): 插入顶点

Graph insertEdge(Edge e): 插入边

void DFS(Vertex v): 从顶点v出发深度优先遍历图。

void BSF(Vertex v): 从顶点v出发宽度优先遍历图。

void shortestPath(Vertex v, int dist[]) : 计算图中顶点v到任意其他顶点的最短距离。

void MST() : 计算图的最小生成树

........

 网络：带权重的图。

3.1 在程序中表示图（邻接矩阵和邻接表）
【注：并不是只有邻接矩阵和邻接表两种表示方法！只是比较常用】

3.1.1 邻接矩阵表示
G[N][N] , N个顶点从0到N-1 编号

如下图可以看出

v0 有两条边v3和v1,所以在矩阵中，(v1,v0),(v3,v0) 是G中的边，所以为1，其他为0
邻接矩阵是（沿图中红线）对称的


邻接矩阵优点

直观、简单、好理解
方便检查任意一堆顶点间是否存在边
方便找任一顶点的所有“邻接点”
方便计算任一顶点的”度“
度：

无向图：对应行(或列)非0元素的个数，如v0的度为2

有向图：对应行非0元素的个数是出度（从该点发出的边数为出度），对应列非0元素的个数是入度（指向该点的边数为入度）

邻接矩阵缺点

 浪费空间：存稀疏图（点很多而边很少），有大量无效元素【对应的，存稠密图（点很多边很多）特别是完全图（任一两个顶点都有边，即临界矩阵内都是1）还是很合算的】
浪费时间：统计稀疏图中的一共有几条边（因为要遍历所有，然后算1的数量，而大多数0元素是白白遍历的）
问题: 无向图的存储，如何省一半空间

解析：

关注下标计算公式为i*（i+1）/2 +j,这样在查询Gij是否右边，只要查找对应下标的值是否为1即可

对于网络来讲，只要把1、0改成权重值即可。





3.1.2 邻接表表示
邻接表：G[N] 为指针数组，对应矩阵每行一个链表，只存非0元素



邻接表优点：

方便找任一顶点的所有”邻接点“
节约稀疏图的空间（对于N个结点和E个边来讲，一共需要N个头指针+2E个结点），在E小于N(N-1)/4时，比较节省空间。
对于无向图，方便计算度；但对于有向图，无法计算（只能计算出度，无法计算入度）
邻接表缺点

对于检查任意一对顶点是否存在边，十分麻烦
3.2 图的建立
3.2.1  用邻接矩阵表示图
MGraph：邻接矩阵图类

package graph;

/**
 * 用邻接矩阵表示图
 * @param <T> 顶点数据类型
 * @param <WT> 邻接矩阵数据(权重)类型
 */
public class MGraph<T, WT> {
    private GraphNode<T,WT> graphNode;
    private final  int MAX_VERTEX_NUM = 10;//初始点最大顶点数量

    /**
     * 内部图结点
     */
    private class GraphNode<T,WT>{
        int vertexNum;//顶点数
        int edgeNum;//边数
        Object[][] matrix;//邻接矩阵WT[i][j]:1 有边，0无边
        Object[] data;//顶点的数据集合

        /**
         * 构造函数
         * @param vertexNum 顶点数
         */
        public GraphNode(int vertexNum) {
            this.vertexNum = vertexNum;
            this.edgeNum = 0;
            matrix = new Object[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
        }
    }

   
}
Edge: 边类

package graph;

/**
 * 边
 * @param <WT> 权重类型
 */
public class Edge<WT> {
    EdgeNode edgeNode;
    class EdgeNode{
        Vertex begin,end;//顶点
        WT weight; //权重
    }
}
Vertex：顶点类

package graph;

/**
 * 顶点
 */
public class Vertex {
    int num;//顶点数字
}
insertEdge操作

    /**
     * 插入边
     * @param edge
     */
    void insertEdge(Edge<WT> edge){
        graphNode.matrix[edge.edgeNode.begin.num][edge.edgeNode.end.num] = edge.edgeNode.weight;//把权重放入对应的位置，无向边则是放1
        graphNode.edgeNum += 1;//边数+1
//        graphNode.matrix[edge.edgeNode.end.num][edge.edgeNode.begin.num] = edge.getEdgeNode().weight; 无向图还要反向插入一次
    }
3.2.2  用邻接表表示图
LGraph: 邻接表图类，主要包含顶点数、边数、邻接表

package graph;
/**
 * 邻接表表示图
 * @param <T> 顶点数据类型
 * @param <WT> 边权重类型
 */
public class LGraph<T,WT> {
    int vertexNum;//顶点数
    int edgeNum;//边数
    private final int MAX_VERTEX_NUM = 10;//初始点最大顶点数量
    AdjacencyList[] adjacencyList;//邻接表

    /**
     * 构造函数
     * @param vertexNum 顶点数
     */
    public LGraph(int vertexNum) {
        this.vertexNum = vertexNum;
        this.edgeNum = 0;
        this.adjacencyList = new AdjacencyList[vertexNum];
    }
AdjacencyList:邻接表类

package graph;

/**
 * 邻接表
 * 内涵两个不同的结点，一个是头结点，指向第一个邻接结点
 * 其余都是邻接结点
 *
 * @param <T> 顶点数据类型
 */
public class AdjacencyList<T, WT> {
    private Node node;

    //    头结点，
    private class Node {
        AdjacencyNode firstEdge;//指向第一条边
        T data;//顶点数据

        public AdjacencyNode getFirstEdge() {
            return firstEdge;
        }

        public void setFirstEdge(AdjacencyNode firstEdge) {
            this.firstEdge = firstEdge;
        }

        public T getData() {
            return data;
        }

        public void setData(T data) {
            this.data = data;
        }
    }

    // 邻接结点
    private class AdjacencyNode {
        Vertex nextVertex;//邻接点,只需要一条，因为，起点已经知道了
        WT weight;//边权重
        AdjacencyNode nextNode;//下一个邻接结点
    }

    /**
     * 插入Edge
     * 先将edge转成AdjacencyNode形式，再插入到表头
     * @param edge
     */
    public void insertEdge(Edge<WT> edge){
        AdjacencyNode adjacencyNode = new AdjacencyNode();
        adjacencyNode.nextVertex = edge.edgeNode.end;
        adjacencyNode.weight = edge.edgeNode.weight;
        adjacencyNode.nextNode = node.firstEdge;
        node.firstEdge = adjacencyNode;
    }

}
insertEdge:图插入边的方法

获取了边所在的那个邻接表
然后调用邻接表中的插入方法，把edge插入（因为我使用了大量private，所以操作在邻接表类中进行会比较方便）

    public void insertEdge(Edge<WT> edge){
        //获取当前edge对应的连接表
        AdjacencyList adjacencyList = this.adjacencyList[edge.edgeNode.begin.num];//获取邻接表的edg对应的数据
        //调用插入方法
        adjacencyList.insertEdge(edge);
    }
3.3 图的遍历
3.3.1 深度优先搜索（Depth First Search, DFS）
若有N个顶点，E条边，时间复杂度是

用邻接表存储图，O（N+E）
用邻接矩阵存储图，O(N²)
3.3.2 广度优先搜索（Breadth Firest Search, BFS）
与树的层序遍历差不多。

从给定的顶点开始。压入队列中。
弹出顶点，再把对应的邻接点压入队列。
如此循环下去遍历
若有N个顶点，E条边，时间复杂度是（与DFS一样）

用邻接表存储图，O（N+E）
用邻接矩阵存储图，O(N²)
3.3.3 图不连通怎么办
连通：如果从v到w存在一条（无向）路径，正称v和w是连通的

路径：v到w的路径是一系列顶点{V, v1, v2, ..., vn, w}的集合。其中任一对相邻节顶点间都有图中的边。

路径长度：路径中边数（如果带权，则是所有边的权重和）。

简单路径：v到w之间的所有顶点都不同

回路：起点等于终点的路径

连通图：图中任意两顶点均连通

连通分量：

对于无向图：极大连通子图

极大顶点数：在家一个顶点就不连通了
极大边数：包含子图中所有顶点项链的所有边
如下图，对于图1，子图1、2满足两个条件，所以是连通分量，而子图3并没有达到极大边数（BD还可以有一条边），子图4没有达到最大顶点数，所以不是连通分量


对于有向图

强连通：有向图中顶点v和w之间存在双向路径（即存在v到w的路径，和w到v的路径），则称v和w是强连通
强连通图:有向图中任意两顶点均强连通
强连通分量：有向图的极大强连通子图 
如下图，对于图1，子图1就是强连通分量，如果加入D，D没有去其他顶点的路径，就不是强连通了。


