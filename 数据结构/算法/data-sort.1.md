---
title: 递归
tags: 
- 递归
categories: 
- 算法
---

# 递归

## 递归满足的三个条件

当面满足以下三个条件时，可以考虑使用递归
- 一个问题的解可以分解为几个子问题的解
- .这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件

具体递归写法为
- 分析出递推公式
- 找出终止条件
- 整合翻译成代码


# 递归警惕事项

### 堆栈溢出

递归的缺点很明显，就是空间复杂度高，容易出现堆栈溢出
```
java.lang.StackOverFlowError
```
函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险

所以，对于高深度的代码，这种方法并不实用。深度较小时使用较适宜

### 重复计算

拿f(n) = f(n-1) + f(n-2)为例

假设n = 6,那么计算过程为
- f(6) = f(5) + f(4)
- f(5)=f(4) + f(3)=f(3) + f(2) + f(2) + f(1)...
- f(4) = f(3) + f(2)= f(2) + f(1) + f(2)

可以发现，f(3)重复计算了多次,为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)

```java
public int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    // hasSolvedList可以理解成一个Map，key是n，value是f(n)
    if (hasSolvedList.containsKey(n)) {
        return hasSovledList.get(n);
    }
    int ret = f(n-1) + f(n-2);
    hasSovledList.put(n, ret);
    return ret;
}
```


# 递归相关问题及应用

## 走步问题

问题描述：有n个台阶，你可以每次走一步到两步，问有几种走法

根据递归满足的三个条件分析
- 分解：完全可以分解为接下来走一步还是走两步,即f(n) = f(n-1) + f(n-2)[ 走一步和走两步的情况 ]
- 子问题：假设走完一步后，依旧是f(n-1) = f(n-2) + f(n-3),除了规模求解思路一致
- 存在递归终止条件,即当n=1或者n=2时，停止运算

那么利用递归就可以得到
```java
int f(int n){
    if(n == 1) return 1;
    if(n == 2) return 2;
    return f(n-1) + f(n-2)
}

//验证下,n = 3的时候
return f(2) + f(1) //renturn 3,正确
//n = 4
return f(3) + f(2) // = 2f(2) + f(1) = 5,正确
```
