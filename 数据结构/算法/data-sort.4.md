---
title: 插入排序
tags: 
- 插入排序
categories: 
- 算法
---

## 插入排序（Insertion Sort）

核心思想：
- 将数组分为两个区间，已排序区间和未排区间
- 已排序区间初始只有数组的第一个元素，其余为未排序区间
- 核从未排序区间取元素，然后从已排序区间插入，保证已排序区间一直有序，直到未排序区间元素为空
- 在实现上，通常采用in-place排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。


![sort3](https://raw.githubusercontent.com/FameLsy/Images/master/data/sort3.png)
 
### 插入排序示例代码

算法描述
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描(为了保证稳定性)
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

 ```java
function insertionSort(a[], n)

    for i ∈ [1, n) do
        for j := i -1 to 0 do
            compare a[j] with a[i] 
            and a[j+1] <- a[j]
        end for

        a[j+1] <- value

    end for
```

### 插入排序性能分析


空间复杂度分析
- 为O(1), 原地排序算法
- (从过程可以看出，无需额外空间)

稳定性分析
- 稳定的排序算法

时间复杂度分析
- 最好情况,时间复杂度O(n)
- 最坏情况,时间复杂度O(n²)
- 平均时间复杂度(O(n²))

## 为什么插入排序比冒泡排序更受欢迎

首先，两种排序都是O(n²)的时间复杂度，原地排序算法,且交换次数都是原属数据的逆序度

但是，它们的是现实，存在差异

```java
//冒泡排序中数据的移动操作
if (a[j] > a[j+1]) { // 交换
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
    flag = true;
}
//插入排序中数据的移动操作：
if (a[j] > value) {
    a[j+1] = a[j]; // 数据移动
} else {
break;
}
```

可以看出，冒泡排序狡猾需要3个赋值操作，而插入排序只需要一个；也就是说，排入排序执行赋值操作只需要冒泡排序的1/3时间