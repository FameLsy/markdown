---
title: 归并排序
tags: 
- 归并排序
categories: 
- 算法
---

## 归并排序

核心思想：
- 要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
- 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决,可用递归实现
- 使用递归来实现

![sort4](https://raw.githubusercontent.com/FameLsy/Images/master/data/sort4.png)

### 归并排序示例代码

递归法（Top-down）
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

迭代法（Bottom-up）
1. 将序列每相邻两个数字进行归并操作，形成ceil(n/2)}个序列，排序后每个序列包含两/一个元素
2. 若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4)} 个序列，每个序列包含四/三个元素
3. 重复步骤2，直到所有元素排序完毕，即序列数为1


```java
//p和r分别为数组起始位置和接属位置,q则为p和r的中间位置
merge_sort(p...r)= {
    merge_sort(merge_sort(p...q), merge_sort(q+1...r))
    merge(a[p...q], a[q+1...r])
}
```

终止条件为: p >= r

转换成代码
```java

function merge_sort(a[], n) 
    merge_sort_c(a[], 0, n-1)
end function

// p <- 0, r <- n-1
function merge_sort_c(a[], p, r)
    // 递归终止条件
    if p >= r then return
    
    // 取p到r之间的中间位置q
    q = (p+r) / 2

    //分治
    a[p...q] <- merge_sort_c(a[], p, q)
    a[q+1...r] <- merge_sort_c(a[], q+1, r)

    //合并(合并时进行排序)
    merge(a[p...r], a[p...q], a[q+1...r])
end function
```


### 归并排序的性能分析

空间复杂度分析
- 空间复杂度为O(n),不是原地排序

稳定性分析
- 稳定排序

时间复杂度分析
- 最好情况,时间复杂度O(nlongn)
- 最坏情况,时间复杂度O(nlongn)
- 平均时间复杂度O(nlongn)
- (关于复杂度可参考：[如何分析递归函数的复杂度]())


