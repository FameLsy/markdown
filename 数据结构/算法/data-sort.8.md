---
title: 桶排序
tags: 
- 桶排序
categories: 
- 算法
---

## 桶排序（Bucket sort）

核心思想:
- 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。
- 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了

![桶排序](https://raw.githubusercontent.com/FameLsy/Images/master/data/桶排序.png)


桶排序对要排序数据的要求
- 要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序
- 数据在各个桶之间的分布是比较均匀的
- 桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
- 划分之后还是比较大的文件，可以继续划分

### 桶排序示例代码

桶排序算法步骤
- 设置一个定量的数组当作空桶子。
- 寻访序列，并且把项目一个一个放到对应的桶子去。
- 对每个不是空的桶子进行排序。
- 从不是空的桶子里把项目再放回原来的序列中。

```java
// n为划分的桶数
function bucket-sort(array, n) is
//定义多个桶
  buckets
//数据插入对应的桶
  for i = 0 to (length(array)-1) do
    insert array[i] into buckets
//分别排序对应的桶
  for i = 0 to n - 1 do
    next-sort(buckets[i])
//整合
  return the concatenation of buckets[0], ..., buckets[n-1]
```

### 桶排序性能分析

空间复杂度分析
- 空间复杂度为O(n*k),非原地排序

稳定性分析
- 不确定,取决于桶内算法算法

时间复杂度分析
- 最好情况,时间复杂度O(n)
- 最坏情况,时间复杂度O(n*k)
- 平均时间复杂度O(n+k)

关于O(n)复杂度的分析:
- 讲n个数插入到桶内，需要O(n)时间复杂度
- 对每个桶进行排序，假设有m个桶，使用快排的话，复杂度就是O(n/mlog(n/m))
- 整体复杂度就是O(n)+O(n/mlog(n/m))  
  ->O(n(1+1/m)*log(n/m)) 省略常数
  ->O(nlog(n/m))  
  -> 当m接近n的时候，log是一个很小的数，省略，即得O(n)
