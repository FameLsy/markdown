---
title: 数组
tags: 
- 数组
categories: 
- 数据结构
---

# 数组

## 概念

数组（Array）：是一种 线性表 数据结构，用一组 连续 的内存空间，来存储一组具有相同类型的数据

数组两大关键概念
- 线性表：即数据成直线一样的结构，每个线性表上的数据可访问前后两个方向
- 连续的内存空间和相同的类型数据: 这两个限制使数组具备了“随机访问” 的特性，同时使得数组的部分操作变得低效（删除、更新等）

示例：
```
int[] a= new int[10];
```

数组的内存地址计算如下
- a[i]_addree = base_address + i * data_type_size
- 假设内存块的首地址base_address = 10;
- int数据类型，所以data_type_size = 4

由此可以得到a[10]的内存空间为连续的1000~1039

![array](https://raw.githubusercontent.com/FameLsy/Images/master/data/array.png)

---
关于“数组适合查找，查找时间复杂度为O(1)”的描述 实际上不够准确,因为即使是排序好的数组，使用二分查找，复杂度也是O(longn)

正确描述应该是：“数组适合查找，且支持随机访问，根绝下表随机访问的时间复杂度为O(1)”

---

## 数组的插入
数组为了保持内存的连续性，插入和删除操作比较低效

比如我们要将一个数据插入到数组中的第K个位置，需要
- 把第K个位置腾出来
- k~n的元素往后移动一位
- 如果k是末尾，那时间复杂度就是O(1)；如果是头部时间复杂度就是O(n),平均复杂度就是(1+2+3...+n)/n = O(n)

由此可见，对于插入一个数的操作，非常低效。

但是，对于数组仅仅只是被当作一个存储数据的集合，对于其内的数据没有任何规律的话，可以避免大规模的数据迁移，方法就是
- 将第K位置的元素放到数组元素最后
- 新的元素放到k的位置
- 好处就是插入的复杂度降为O(1)

![array2](https://raw.githubusercontent.com/FameLsy/Images/master/data/array2.png)

## 数组的删除

如果我们要将一个数据从第k的位置删除，那么
- 把第k位置的元素删除
- k~n的数据向前一迁移
- 平均复杂度：O(n)

但是，如果我们对数组数据的连续性并没有要求，为了防止删除一次，就迁移一次数据，而是将多次删除一起执行，可以使用如下方法
- 并不删除数据，而是标识该数据已经被删除
- 当数组空间不足时，再执行一次真正的删除操作
- 好处就是大大减少了删除导致的数据迁移


![array3](https://raw.githubusercontent.com/FameLsy/Images/master/data/array3.png)

## 数组的访问越界

众所周知,如下代码会出现访问越界
```
int [] a = new int[3];
a[3] = 10;
```

访问数组，其本质时访问一段连续内存，只要数组通过偏移计算得到的内存地址可用，程序可能不会报错(Java自身会做越界检查，越界抛出java.lang.ArrayIndexOutOfBoundsException)

## 数组和容器

针对数组类型，Java提供了很多容器，如ArrayList,并且实现很多逻辑，如扩容逻辑。但是，有些时候，使用数组会更加合适
- 存储基本类型，ArrayList无法存储基本类型，而Autoboxing、Unboxing有一定的性能消耗
- 数据大小事先已知，且对数据操作非常简单，不需要容器提供的大部分方法，也可以使用数组
- 多维数组，用数组会更加直观

## 为什么数组会是从0开始

前面看完后，基本上可以了解数组为什么从0开始

从数组内存模型可以看出，所谓的下标其实就是“偏移offset”如,a[0]就是偏移为0的位置，也就是首地址

计算公式如下
```
a[k]_address = base_address + k * type_size
```
但如果从1开始计算，那么计算公式如下
```
a[k]_address = base_address + (k-1) * type_size
```

两个公式相比较，从1开始计算，对于CPU来说，需要多一次减法操作