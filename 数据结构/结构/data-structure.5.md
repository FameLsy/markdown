<!-- ---
title: 跳表
tags: 
- 跳表
categories: 
- 数据结构
--- -->

# 跳表

什么是跳表？
- 链表的改造，可以实现类似于二分查找的算法
- (Redis中的有序集合（Sorted Set）就是用跳表来实现的)

核心思想：
- 对链表建立“索引”
- 如，每两个结点提取一个结点到上一级，把抽出来的那一级叫作索引或索引层(当然，可以每n个结点取一个结点，这样可以节省额外空间，不过当存储的对象值比索引大的多少，可以忽略占用额外空间)
- 结点存在next结点指向下一个结点，down结点指向下一级结点

![跳表](https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表.png)

## 跳表查找

算法
1. 有数据x，首先查询最顶级索引结点y
2. 如果Node[y] < x，再查询next结点z
3. 如果Node[z] > x, 说明该值再[y,z]之间，然后找到y的down结点
4. 重复1-3
5. 如果 Node[y] > x,则表明x不存在(已经是最小的了)

每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第三级索引
的结点个数大约就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是n/(2k)。

假设索引有h级，最高级的索引有2个结点。通过上面的公式，我们可以得到n/(2h)=2，从而求得h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是log2n。
我们在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是O(m*logn)。

空间复杂度分析
- 空间复杂度为O(n),非原地排序算法

稳定性分析
- 是一种数据结构，不存在稳定性

时间复杂度分析
- 最好情况,时间复杂度O(logn)
- 最坏情况,时间复杂度O(logn)
- 平均时间复杂度O(logn)

时间复杂度分析
- 每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第k级的个数就是n/(2k)
- 假设索引的k级最高级结点数为2，则n/(2k) = 2-> k= logn-1
- 对于每一层，需要遍历m个结点，那么时间复杂度即为O(m*logn)
- 因为我们使用的是每两个结点取一个索引，所以，最多也就需要遍历3个结点(y、z以及它们中间的结点)，即m <=3,则整个的时间复杂度为O(logn)

![跳表2](https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表2.png)

## 跳表插入删除

跳表的插入和删除，只需要通过查找找到位置，然后进行O(1)的插入/删除操作即可，所以时间复杂度为O(logn)

## 跳表索引动态更新

当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

![跳表3](https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表3.png)

跳表通过随机函数来维护“平衡性”,比如随机函数生成了值K，就将这个结点添加到第一级到第K级这K级索引中

![跳表4](https://raw.githubusercontent.com/FameLsy/Images/master/data/跳表4.png)

## 跳表示例代码

跳表的实现较为复杂，可以查看Redis中关于有序集合的跳表实现。