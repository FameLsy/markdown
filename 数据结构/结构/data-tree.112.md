<!-- Bmore Tree -->

MySQL底层使用的是B+ Tree数据结构，而该数据结构，需要满足以下需求
1. 根据某个值查找数据，比如select * from user where id=1234；
2. 根据区间值来查找某些数据，比如select * from user where id > 1234 and id < 2345
3. 支持快速查询、插入等操作

综合以上需求来分析，我们来看一下较为合适的数据结构散列表、平衡二叉查找树、跳表
1. 散列表：查询性能很好，时间复杂度是O(1)；但散列表不能支持按照区间快速查找数据
2. 平衡二叉查找树：查询的性能也很高，时间复杂度是O(logn)，同样不支持按照区间快速查找数据
3. 跳表：支持快速地插入、查找、删除数据，对应的时间复杂度是O(logn)，并且支持区间快速地查找数据


跳表显然是可以解决这个问题，但MySQL使用的B+树，虽然与跳表类似，但是通过改造平衡二叉查找树演化而来的

# 平衡二叉树到B+ 树

改造如下
1. 树中的节点并不存储数据本身，而是只是作为索引
2. 把每个叶子节点串在一条链表上，链表中的**数据是从小到大有序的**

如下图插入7的话，会插入到6-10之间，会导致10节点有3个字节点，必须进行索引调整(调整方法稍后看到)

![B+树](https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树.png)

如果要求某个区间的值只需要拿区间的起始值，在树中进行查找），当查找到某个叶子节点之后（如查找到少于这个区间的叶子节点，再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。

![B+树2](https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树2.png)

不过，如此设计，必定会占用太多内存。比方说有1亿数据，每个节点占16字节，那么就是差不多1G的空间占用。解决如此大的空间问题，思路是：内存速度为纳秒级别，但容量小。而硬盘容量大，但速度为毫秒级别。，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘IO操作。**树的高度就等于每次查询数据时磁盘IO操作的次数**，所以，优化重点是利用硬盘存储节点，并尽量减少IO次数，即减少树的高度。

如何减少树的高度: 从二叉树到M叉树,如下图，16个数据二叉树高度为4，而五叉树高度为2

![M叉树](https://raw.githubusercontent.com/FameLsy/Images/master/data/M叉树.png)

不难发现，对于相同个数的数据构建m叉树索引，m叉树中的m越大，那树的高度就越小。那么，M该如何取值？
不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次IO操作。所以，我们在选择m大小的时候，要**尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。**

```
# linux 获取内存页大小，一般都是4K
getconf PAGE_SIZE
```

# 插入数据

往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过m（m值是提前计算号的），这个节点的大小超过了一个页的大小，一旦超过，那必然会进行多次IO了；所以，必须保证该树是个M叉树，必须进行索引调整(会导致导致写入速度降低)

调整思路:
将这个节点分裂成两个节点。但是，节点分裂之后，如果上层父节点的子节点个数就有可能超过m个,将父节点也分裂成两个节点，如下图，图中的B+树是一个三叉树。我们限定叶子节点中，数据的个数超过2个就分裂节点；非叶子节点中，子节点的个数超过3个就分裂节点(注意B+树中链表顺序是由大到小，一旦超出就需要进行索引调整)

-![B+树3](https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树3.png)


# 删除数据

同样的，删除数据也需要重新调整索引，因为频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率

调整思路：设置一个阈值
- 在B+树中，这个阈值等于m/2
- 如果某个节点的子节点个数小于m/2，将它跟相邻的兄弟节点合并
- 如果合并之后结点的子节点个数超过m，就使用插入时的调整方法，分裂节点

-![B+树4](https://raw.githubusercontent.com/FameLsy/Images/master/data/B+树4.png)

