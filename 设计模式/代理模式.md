---
title: 代理模式
date: 2019 01-01 00:00:01
tags: 
- 代理模式
- 结构型模式
categories: 
- 设计模式
---
# 代理模式

概念：
- 使用代理对象完成用户请求，屏蔽用户对真是对象的访问

使用场景：

优点：
1. 职责清晰
2. 高扩展性
3. 智能化
4. 可以对代理方法添加业务逻辑

缺点
1. 处理速度可能变慢
2. 代理模式实现可能非常复杂

## 静态代理（完成延迟加载）

在系统启动时，将消耗资源最多的方法都使用代理模式分离，可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时再由代理类单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。

模式构成:
![proxy](https://raw.githubusercontent.com/FameLsy/Images/master/design/proxy.png)

代码解释
1. 主题接口:真实对象和代理对象都实现了该接口
2. 代理类:持有Subject引用，可以将请求转发给Subject
3. 真实对象

主题接口
```java
/**
 * 主题接口
 * 真实对象和代理对象都实现了该接口
 * @author liisyu
 * @date 2019/2/23
 */
public interface Subject {
    /**
     * 处理请求
     */
    void request();
}

```
代理类
```java
/**
 * 代理类
 * 持有Subject引用，可以将请求转发给Subject
 * @author liisyu
 * @date 2019/2/23
 */
public class Proxy implements Subject {
    private Subject real;
    @Override
    public void request() {
        //可以插入其他业务逻辑
        // 真正需要的时候才创建对象
        if (real == null){
            real = new RealSubject();
        }
        real.request();
        //可以插入其他业务逻辑

    }
}
```

真是对象
```java
/**
 * 真实对象
 * 真正做事的类
 * @author liisyu
 * @date 2019/2/23
 */
public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("真实地处理请求");
    }
}

```

测试
```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class TestMain {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
//        只有用到时，才会创建真实对象
        proxy.request();
    }
}

// print
//真实地处理请求

```

## 动态代理
概念
1. 动态代理是指在运行时动态生成代理类
2. 生成动态代理类的方法很多，JDK自带的动态代理、CGLIB、Javassist,ASM库(推荐CGLIB)
优点：
1. 不需要为真实主题写一个形式上完全一样的封装类，假如主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；
2. 使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。

JDK方式生成代理对象,对代理类进行了如下修改

```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class ProxyHandler implements InvocationHandler {
    private Subject real;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (real == null){
            real =  new RealSubject();
            method.invoke(real,args);
        }
        return null;
    }

    /**
     * 生成代理对象
     */
    public static Subject createProxy(){
        //参数含义
        //1. 类加载器
        //2. 代码要用来代理的接口,接口决定我们要代理哪些方法
        //3. 一个InvocationHandler类,决定用谁来完成代理操作
        Subject proxy = (Subject)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Subject.class},new ProxyHandler());
        return proxy;
    }
}
```

测试,当使用代理类执行时，会交给ProxyHandler的.invoke()方法处理
```java
public class TestMain {
    public static void main(String[] args) {
        Subject proxy =  ProxyHandler.createProxy();
        proxy.request();
    }
}
```


