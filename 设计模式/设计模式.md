---
title: 设计模式
date: 2019 01-01 00:00:01
tags: 
- 设计模式
categories: 
- 设计模式
---

# 策略模式
概念：  
1. 定义了算法族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户（
2. 通俗的将就是将变化的部分和不变化的部分独立开

使用场景：
 1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 
 2. 一个系统需要动态地在几种算法中选择一种。 
 3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。(在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护)

优点:
1. 算法可以自由切换
2. 避免使用多重条件判断
3. 扩展性良好。

模式构成:
1. 需要一个Strategy接口来封装策略方法，供实现类以不同算法实现
2. Context类使用该策略，通过注入不同的策略实现类，来完成一个方法不同的算法

![策略模式](https://raw.githubusercontent.com/FameLsy/Images/master/design/Strategy.png)

代码解释:
1. 抽象策略(Strategy)：将通用的方法封装起来
2. 具体策略(StrategyImpl*):对方法实现不同的算法
3. 策略使用类(Context): 通过注入不同的具体策略，来实现不同的算法

创建一个策略接口，定义一个通用的策略方法
```java
package com.liisyu.strategypattern;

/**
 * 策略模式
 * @author liisyu
 */
public interface Strategy {
    /**
     * some method to invoke
     * @param objects param
     * @return Object
     */
    Object doMethod(Object[] objects);
}
```

创建策略接口实体类,根据不同需求实现不同的策略方法
```java
/**
 * StrategyImpl 1
 * @author liisyu
 */
public class StrategyImplAdd  implements Strategy{
    @Override
    public Object doMethod(Object[] objects) {
        //do for something with StrategyImpl_1.doMethod;
        return null;
    }
}

/**
 * StrategyImpl 12
 * @author liisyu
 */
public class StrategyImplDelete implements Strategy{
    @Override
    public Object doMethod(Object[] objects) {
        //do for something with StrategyImplDelete.doMethod;
        return null;
    }
}

/**
 * StrategyImpl 3
 * @author liisyu
 */
public class StrategyImplUpdate implements Strategy{
    @Override
    public Object doMethod(Object[] objects) {
        //do for something with StrategyImplUpdate.doMethod;
        return null;
    }
}
```

创建使用策略的类
```java
/**
 * a class that uses strategy
 * @author liisyu
 */
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy){
        this.strategy = strategy;
    }

    public Object executeStrategy(Object[] objects){
        return strategy.doMethod(objects);
    }

}
```

使用,通过传入不同的策略实现类，实现不同的需求
```java
/**
 * Test Class
 * @author liisyu
 */
public class TestMain {
    public static void main(String[] args) {
        Context context = new Context(new StrategyImplAdd());
        context.executeStrategy(null);

        context = new Context(new StrategyImplDelete());
        context.executeStrategy(null);

        context = new Context(new StrategyImplUpdate());
        context.executeStrategy(null);


    }
}
```

# 观察者模式

概念： 
-. 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新

使用场景：
1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
2. 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
3. 一个对象必须通知其他对象，而并不知道这些对象是谁。
4. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

优点:
1. 观察者和主题是抽象耦合的
2. 改变观察者或主题，并不会影响另一方

模式构成：

![observer](https://raw.githubusercontent.com/FameLsy/Images/master/design/observer.png)

代码解释:
1. 主题接口和观察者实为多对多，或一对多，多对一的关系，这里使用了Subject接口和Observer接口
2. 主题实现类包含了观察者，方便注册，删除，通知观察者
3. 观察者包含了主题接口，注册了该接口即可收到主题的通知 

主题接口，包含注册、删除，通知观察者的三个方法

```java
/**
 * 主题类
 * @author  liisyu
 * @date 2019/02/22
 */
public interface Subject{
    /**
     * 注册观察者
     * @param observer 观察者
     */
    void registerObserver(Observer observer);

    /**
     * 删除观察者
     * @param observer 观察者
     */
    void removeObserver(Observer observer);

    /**
     * 提示所有观察者
     */
    void notifyObservers();
}
```

观察者接口,主要包含一个更新信息的方法
```java
/**
 * 观察者接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Observer {
    /**
     * 用于观察者更新
     * @param  info 参数
     */
    void update(String info);

    //观察者的其他方法
}

```

主题实现类，除了属性外，还内置了一个观察者集合，用于保存注册的观察者
```java
/**
 * @author  liisyu
 * @date 2019/02/22
 */
public class SubjectImpl implements Subject {
    private List<Observer> observers;

    private String info;

    public SubjectImpl() {
        observers = new ArrayList<>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        int i = observers.indexOf(observer);
        if (i >= 0) {
            observers.remove(i);
        }

    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers){
            observer.update(info);
        }
    }

    /**
     * 信息改变时，提醒所有观察者
     */
    public void infoChange(){
        notifyObservers();
    }

    /**
     * 修改信息，并触发改变
     * @param info 新的状态
     */
    public void setStatus(String info) {
        this.info = info;
        System.out.println("信息改变成: " + this.info);
        infoChange();
    }

    //其他方法
}
```
观察者实现类，内置了一个主题接口，用于注册主题(如果是多个主题，也需要用到集合)
```java
/**
 * 观察者实现类
 * @author liisyu
 * @date 2019/02/22
 */
public class ObserverImpl implements Observer {
    private String info;
    private Subject subject;

    public ObserverImpl(Subject subject) {
        this.subject = subject;
        subject.registerObserver(this);
    }

    @Override
    public void update(String info) {
        this.info = info;
        System.out.println("观察者更新了");
    }

    public Subject getSubject() {
        return subject;
    }

    public void setSubject(Subject subject) {
        this.subject = subject;
    }
}
```

使用
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        SubjectImpl subject = new SubjectImpl();

        ObserverImpl observer = new ObserverImpl(subject);

        subject.setStatus("更新");
    }
}
```

# 装饰者模式
概念:
- 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

使用场景：  
1. 扩展一个类的功能
2. 动态增加功能
3. Java的I/O流

优点:  
- 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

模式构成:  

![装饰者模式](https://raw.githubusercontent.com/FameLsy/Images/master/design/Decorator.png)

代码解释:
1. 需要一个顶级的组件类或接口
2. 被装饰者和装饰类都需要继承/实现它
3. 装饰者需要注入被装饰者的类，以便在原有基础上添加新功能

创建组件抽象类(也可以是接口),我们将对它的两个方法进行装饰
```java
/**
 * 组件抽象类
 * @author liisyu
 * @date 2019/02/22
 */
public abstract class BaseComponent {
    String description = "Unknown component";
    /**
     * 组件的方法A
     */
    public String getDescription(){
        return description;
    }

    /**
     * 获取功能
     * @return 功能描述
     */
   public abstract String features();
}
```
组件子类,把被装饰者当成了机器人，那么装饰器就是为它装备各种武器
```java
/**
 * 头部组件(就当拼装机器人了)
 * @author liisyu
 * @date 2019/02/22
 */
public class RobotComponent extends BaseComponent{
    public RobotComponent() {
        description = "我是一个机器人";
    }

    @Override
    public String features() {
        return "战争武器";
    }
}
```
创建基本的装饰器,它通用扩展于BaseComponent
```java
/**
 * 装饰器
 * @author liisyu
 * @date 2019/02/22
 */
public abstract class BaseDecorator extends BaseComponent{
    /**
     * 这里重新抽象化了getDescription,目的就是让其子类不得不重写它
     * @return 返回描述
     */
    @Override
    public abstract String getDescription();
}
```
装饰器子类,这里定义了装备枪和炸弹的装饰器
```java
/**
 * 装饰器实体类
 * @author liisyu
 * @date 2019/02/22
 */
public class GunDecorator extends BaseDecorator {
    /**
     * 用一个变量引用被装饰柱
     */
    private BaseComponent baseComponent;

    /**
     * 将被装饰者传入到装饰器中
     * @param baseComponent
     */
    public GunDecorator(BaseComponent baseComponent) {
        this.baseComponent = baseComponent;
    }

    @Override
    public String getDescription() {
        return baseComponent.getDescription() + ",装备枪";
    }

    @Override
    public String features() {
        return baseComponent.features() + ",大范围杀伤力,战斗力+5";
    }
}

/**
 * 装饰器实体类
 * @author liisyu
 * @date 2019/02/22
 */
public class BombDecorator extends BaseDecorator {
    private BaseComponent baseComponent;

    public BombDecorator(BaseComponent baseComponent) {
        this.baseComponent = baseComponent;
    }

    @Override
    public String getDescription() {
        return baseComponent.getDescription() + ",装备炸弹";
    }

    @Override
    public String features() {
        return baseComponent.features() + ",攻击范围+500px";
    }
}

```

使用,先创建了一个机器人，然后分别装上枪和炸弹
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        //创建一个机器人组件
        BaseComponent baseComponent = new RobotComponent();
        System.out.println(baseComponent.getDescription() + "&&" + baseComponent.features());

        //装备枪
        baseComponent = new GunDecorator(baseComponent);
        System.out.println(baseComponent.getDescription() + "&&" + baseComponent.features());

        //装备炸弹
        baseComponent = new BombDecorator(baseComponent);
        System.out.println(baseComponent.getDescription() + "&&" + baseComponent.features());
    }
}

//print
我是一个机器人&&战争武器
我是一个机器人,装备枪&&战争武器,大范围杀伤力,战斗力+5
我是一个机器人,装备枪,装备炸弹&&战争武器,大范围杀伤力,战斗力+5,攻击范围+500px

```

# 工厂模式
工厂模式有三个分类
1. 简单工厂模式
2. 工厂方法模式
3. 抽象工厂模式

概念：  
1. 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。
2. 

优点:
1. 一个调用者想创建一个对象，只要知道其名称就可以了。 
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
32. 屏蔽产品的具体实现，调用者只关心产品的接口。

## 简单工厂模式

使用场景：
- 创建的对象较少


模式构成:

![simple](https://raw.githubusercontent.com/FameLsy/Images/master/design/simple.png)

代码解释:（以机器人厂为例）
1. 抽象接口(Robot): 子类定制不同实例
2. 具体实例
3. 工厂：从工厂获取各类实例(可以使用反射进行优化)

创建一个接口
```java
/**
 * 机器人接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Robot {
    /**
     * 机器人出击方法描述
     */
    void go();
}
```
实例
```java
/**
 * 机器人实现类（扎古）
 * @author liisyu
 * @date 2019/02/22
 */
public class Zhagu implements Robot {
    public Zhagu() {
        System.out.println("扎古，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速500公里/小时");
    }
}

/**
 * 机器人实现类(高达Zero)
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaZero implements Robot {
    public GaodaZero() {
        System.out.println("高达，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速1500公里/小时，瞬移100米");
    }
}
```

工厂类,这里提供了两种方式进行获取实例
```java
/**
 * 机器人工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class RobotFactory {
    /**
     * 获取机器人
     * @param robotType 机器人类型
     * @return 机器人实例
     */
    public static Robot getRobot(String robotType){
        if (robotType == null || robotType.length() == 0){
            return null;
        }
        if ("zhagu".equalsIgnoreCase(robotType)) {
            return new Zhagu();
        }else if("gaoda".equalsIgnoreCase(robotType)){
            return new GaodaZero();
        }
        return null;
    }

    /**
     * 反射方式获取机器人
     * @param robotType 机器人类型
     * @return  机器人实例
     */
    public static Robot getRobot2(String robotType) {
        Robot robot = null;
        try {
            robot =  (Robot) Class.forName("com.liisyu.factory.simple." + robotType).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return robot;
    }
}

```

使用
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        Robot robot = RobotFactory.getRobot("gaoda");
        robot.go();

        robot = RobotFactory.getRobot2("zhagu");
        robot.go();
    }
}

//print
高达，出击！
时速1500公里/小时，瞬移100米
扎古，出击！
时速500公里/小时
```
##  工厂方法模式

使用场景：
1. 一个类不知道它所需要的对象的类
2. 一个类通过其子类来指定创建哪个对象
3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中

模式构成:

![mehotd](https://raw.githubusercontent.com/FameLsy/Images/master/design/mehotd.png)

代码解释
1. 抽象工厂类
2. 抽象对象类
3. 工厂类实现，每一个对象对应一个工厂
4. 对象实现类

工厂接口
```java
/**
 * 工厂接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Factory {
    /**
     * 工厂方法,所有子类必须继承
     */
    Robot factoryMethod();
}

```

机器人接口
```java
/**
 * 机器人接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Robot {
    /**
     * 机器人出击方法描述
     */
    void go();
}

```

工厂实现类
```java
/**
 * 高达Zero工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaFactory implements Factory{

    @Override
    public Robot factoryMethod() {
        return new GaodaZero();
    }
}


/**
 * 扎古工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class ZhaguFactory implements Factory {

    @Override
    public Robot factoryMethod() {
        return new Zhagu();
    }
}

```

对象实例
```java
/**
 * 机器人实现类（扎古）
 * @author liisyu
 * @date 2019/02/22
 */
public class Zhagu implements Robot {
    public Zhagu() {
        System.out.println("扎古，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速500公里/小时");
    }
}

/**
 * 机器人实现类(高达Zero)
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaZero implements Robot {
    public GaodaZero() {
        System.out.println("高达，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速1500公里/小时，瞬移100米");
    }
}
```

使用,实例化不同工厂，获取相应的对象
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        Robot robot = new GaodaFactory().factoryMethod();
        robot.go();

        robot = new ZhaguFactory().factoryMethod();
        robot.go();
    }
}
//print
高达，出击！
时速1500公里/小时，瞬移100米
扎古，出击！
时速500公里/小时
```

## 抽象工厂模式

使用场景：
- 工厂不止创建一个对象

模式构成:

![abstract](https://raw.githubusercontent.com/FameLsy/Images/master/design/abstract.png)

代码解释:
1. 抽象工厂类（复数）
2. 抽象对象类（复数）
3. 工厂类实现，每一个对象对应一个工厂
4. 对象实现类

工厂接口,包含了两个方法，获取机器人和武器
```java
/**
 * 工厂接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Factory {
    /**
     * 工厂方法,所有子类必须继承
     * @return 机器人实体类
     */
    Robot factoryMethod();

    /**
     * 工厂方法,所有子类必须继承
     * @return 武器实体类
     */
    Arms factoryMethod2();
}
```

机器人接口
```java
/**
 * 机器人接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Robot {
    /**
     * 机器人出击方法描述
     */
    void go();
}

```
工厂实现类,高达工厂产高达和炸弹，扎古工厂产扎古和枪
```java
/**
 * 高达Zero工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaFactory implements Factory {

    @Override
    public Robot factoryMethod() {
        return new GaodaZero();
    }

    @Override
    public Arms factoryMethod2() {
        return new Bomb();
    }
}


/**
 * 扎古工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class ZhaguFactory implements Factory {

    @Override
    public Robot factoryMethod() {
        return new Zhagu();
    }

    @Override
    public Arms factoryMethod2() {
        return new Guns();
    }
}

```

对象实例
```java
/**
 * 机器人实现类（扎古）
 * @author liisyu
 * @date 2019/02/22
 */
public class Zhagu implements Robot {
    public Zhagu() {
        System.out.println("扎古，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速500公里/小时");
    }
}

/**
 * 机器人实现类(高达Zero)
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaZero implements Robot {
    public GaodaZero() {
        System.out.println("高达，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速1500公里/小时，瞬移100米");
    }
}
```

使用
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        Factory factory = new GaodaFactory();
        Robot robot = factory.factoryMethod();
        Arms arms = factory.factoryMethod2();
        robot.go();
        arms.run();

        factory = new ZhaguFactory();
        robot = factory.factoryMethod();
        arms = factory.factoryMethod2();
        robot.go();
        arms.run();
    }
}
//print
高达，出击！
时速1500公里/小时，瞬移100米
爆炸输出
扎古，出击！
时速500公里/小时
单点高伤害
```

# 单例模式

概念：  
1. 对象只有一个实例
2. 静态变量也可以实现单例，但越是耗资源的对象，就越浪费（如果只在需要时创建，就可以避免这种浪费）
3. 分懒汉式和饿汉式

使用场景：
1. 对于线程池、缓存、对话框、注册表、日志对象、充当打印机等，这些需要保证只有一个实例对象
2. 

优点:
1. 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
2. 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

## 饿汉式
1. 饿汉式（线程安全）
2.  饿汉式（枚举实现）
全局的单例实例在类装载时构建

### 饿汉式（线程安全）
```java
/**
 * 饿汉式线程安全
 * @author liisyu
 * @date 2019/02/22
 */
public class Hungry {

    /**
     * 静态初始化变量，保证单例且线程安全
     */
    private static Hungry hungry = new Hungry();

    /**
     * 私有化构造器，防止创建
     */
    private Hungry(){};
    public static Hungry getHungry() {
        return hungry;
    }

    public void doMethod(){
        System.out.println("do something");
    }
}
```

### 饿汉式（枚举实现）
```java
/**
 * 饿汉式枚举
 * @author liisyu
 * @date 2019/02/22
 */
public enum HungryEnum {
    /**
     * 唯一实体类
     */
    HUNGRY_INSTANCE;

    public void doMethod(){
        System.out.println("do something");
    }
}

```

## 懒汉式
1. 懒汉式（非线程安全)
2. 懒汉式（线程安全）
3. 懒汉式(双重检查加锁版本)
4. 懒汉式（登记式/静态内部类方式）


### 懒汉式（非线程安全)
```
/**
 * 懒汉式非线程安全
 * @author liisyu
 * @date 2019/02/22
 */
public class Lazy {
    private static Lazy lazy;

    private Lazy(){};

    public static Lazy getLazy(){
        if (lazy == null){
            //这里有可能出现线程问题
            lazy = new Lazy();
        }
        return lazy;
    }
}
```
### 懒汉式（线程安全）
如果想要线程安全，可以使用synchronized,不过每次获取都需要经过一遍锁，不推荐
```
   public static synchronized Lazy getLazy(){
        if (lazy == null){
            //这里有可能出现线程问题
            lazy = new Lazy();
        }
        return lazy;
    }
```

###  懒汉式(双重检查加锁版本)
1. 第一次先检查是否为null，再进入同步
2. 第二次检查是否为Null，null才创建实例。
```java
/**
 * 懒汉式(双重检查加锁版本)
 * @author liisyu
 * @date 2019/02/22
 */
public class LazyDoubleLock {
    /**
     * volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量
     */
    private volatile static LazyDoubleLock lazy;
    
    private LazyDoubleLock() {
    }
    
    public static LazyDoubleLock getInstance() {
        //检查实例，如果不存在，就进入同步代码块
        if (lazy == null) {
            //只有第一次才彻底执行这里的代码
            synchronized(LazyDoubleLock.class) {
                //进入同步代码块后，再检查一次，如果仍是null，才创建实例
                if (lazy == null) {
                    lazy = new LazyDoubleLock();
                }
            }
        }
        return lazy;
    }
}

```
### 懒汉式（登记式/静态内部类方式）
只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类(只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题)
```java
/**
 * 懒汉式(静态内部类方式)
 * @author liisyu
 * @date 2019/02/22
 */
public class LazyInnerClass {
    private static class SingletonHolder {
        private static final LazyInnerClass LZAY = new LazyInnerClass();
    }
    private LazyInnerClass (){}

    public static final LazyInnerClass getInstance() {
        return SingletonHolder.LZAY;
    }
}
```
# 命令模式
概念：  
将一个封装成一个对象，从而可以用不同的请求对客户进行参数化

使用场景：
对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，将一组行为抽象为对象，可以实现二者之间的松耦合。

优点:
1. 降低系统耦合度
2. 新的命令可以很容易添加到系统中去

模式构成:

![command](https://raw.githubusercontent.com/FameLsy/Images/master/design/command.png)

代码解释:
1. 抽象命令类(Command):execute()方法供子类执行接收者的命令，undo()方法撤销命令
2. 命令实体类
3. 接收者类(Receiver): 任何类都可以是接收者类，真正执行逻辑的地方
4. 命令调用者(Invoker):封装了命令，执行excute()方法的地方
5. 客户端类(Client):创建命令，并指定接收者

创建接口
```java
/**
 * 命令接口
 * @author liisyu
 * @date 2019/02/23
 */
public interface Command {
    /**
     * 执行方法
     */
    void execute();

    /**
     * 撤销方法
     */
    void undo();
}
```

接口实现
```java
/**
 * 命令接口
 * （封有Receiver对象，告诉高达该怎么做）
 * @author liisyu
 * @date 2019/2/23
 */
public class GoCommand implements Command {
    private Receiver receiver;

    public GoCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.action();
    }

    @Override
    public void undo() {
        receiver.undoAction();
    }
}

```

命令调用者
```java
/**
 * 命令调用者
 * (模拟高达战舰，拥有一系列的命令，告诉高达们怎么作战)
 *
 * @author liisyu
 * @date 2019/2/23
 */
public class Invoker {
    private List<Command> commands;
    private Command noCommand;
    public Invoker(){
        this.commands = new ArrayList<>();
        noCommand = new NoCommand();
    }
    public void setCommand(Command command) {
        commands.add(command);
    }

    public void invokeCommand(){
        for (Command command : commands){
            command.execute();
//           追踪上一条命令
            noCommand = command;
        }

//       如有需要，可以执行完清除命令
        commands.clear();
    }

    public void undoCommand(){
        noCommand.undo();
    }
}
```

命令接收者
```java
/**
 * 命令接收者
 * 知道如何进行必要的工作，实现这个请求
 * 任何类都可以当接收者
 *(模拟成高达，可以出击或是返航)
 * @author liisyu
 * @date 2019/2/23
 */
public class Receiver {
    public Receiver() {
        System.out.println("Freedom准备就绪！");
    }

    public void action(){
        System.out.println("高达，出击！");
    }

    public void undoAction(){
        System.out.println("高达，返航！");
    }
}
```

客户端
```java
/**
 * 客户端
 *（模拟指挥官）
 * @author liisyu
 * @date 2019/2/23
 */
public class Client {
    public static void main(String[] args) {
        System.out.println("模拟战争开始");
//        首先我们需要一价高达(接收者)
        Receiver receiver = new Receiver();
//        需要下达什么命令呢，出击命令
        GoCommand goCommand = new GoCommand(receiver);
//        我们还需要战舰，用来调用命令
        Invoker invoker = new Invoker();
//        将新的命令输入进去
        invoker.setCommand(goCommand);
//        执行
        invoker.invokeCommand();
//        发生紧急情况，需要撤销命令
        System.out.println("情况不对!");
        invoker.undoCommand();
    }
}
//print
模拟战争开始
Freedom准备就绪！
高达，出击！
情况不对!
高达，返航！
```

无命令类,主要用于撤销操作开始的初始化
```
/**
 *无命令
 * @author liisyu
 * @date 2019/2/23
 */
public class NoCommand implements Command {
    @Override
    public void execute() {
        System.out.println("无命令");
    }

    @Override
    public void undo() {
        System.out.println("无命令可撤销");
    }
}
```

以上模拟了一个高达出击的命令模式
1. 指挥官（Client）决定命令(Command)和谁去接受命令(Receiver)
2. 指挥官不可能喊着高达去执行命令，需要通过战舰(invoker)传达去执行命令
3. 如果有新的命令(new Command(receiver ),无需更改，战舰(invoker.setCommand)完全可以接受它
4. 如果有新的集体(new Receiver()),旧的命令也可以接受它(比方说aCommand.setReceiver(receiver))
5. 出现一对多，对多对方式也可以相应的使用集合


# 适配器模式
概念：
-. 将原本接口不兼容的类可以一起工作


这张图可以很好解释适配器

![适配器](https://raw.githubusercontent.com/FameLsy/Images/master/design/适配器.png)

使用场景：  
1. 有动机地修改一个正常运行的系统接口，用于解决正在运行的项目问题
2. 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。

优点:
1. 可以将两个没有关联的类一起运行
2. 提高了类的复用
3. 添加类的透明度
4. 灵活性好

缺点
1. 过多适配器会导致系统混乱

模式构成:
![adapter](https://raw.githubusercontent.com/FameLsy/Images/master/design/adapter.png)

代码解释:
1. 目标接口(Target)
2. 被适配的对象(adaptee)
3. 适配器(Adapter):连接1，2，所有委托都给被适配的对象

目标接口
```java
/**
 * 目标接口
 *
 * @author liisyu
 * @date 2019/2/23
 */
public interface Target {
    /**
     * 客户端请求处理的方法
     */
    void request();
}

```
被适配的对象
```java
/**
 * 被适配的对象
 * @author liisyu
 * @date 2019/2/23
 */
public class Adaptee {
    /**
     * 原本存在的方法
     */
    public void specificRequest(){
        System.out.println("被适配的对象方法");
    }
}

```

适配器
```java
/**
 * 适配器
 * @author liisyu
 * @date 2019/2/23
 */
public class Adapter implements Target{
    private Adaptee adaptee;

    /**
     * 传入被适配的对象
     * @param adaptee 需要被适配的对象
     */
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.specificRequest();
    }
}

```

使用
```java
/**
 * 客户端
 * @author liisyu
 * @date 2019/2/23
 */
public class Client {
    public static void main(String[] args) {
//        创建需要被适配的对象
        Adaptee adaptee = new Adaptee();
//        创建适配器
        Target target = new Adapter(adaptee);
//        请求处理
        target.request();

    }
}
```

## JDK中的适配器
```java
java.util.Arrays#asList()
java.io.InputStreamReader(InputStream)
java.io.OutputStreamWriter(OutputStream)
```

Java I/O 库大量使用了适配器模式，如 ByteArrayInputStream 是一个适配器类，它继承了 InputStream 的接口，并且封装了一个 byte 数组。换言之，它将一个 byte 数组的接口适配成 InputStream 流处理器的接口。

在 OutputStream 类型中，所有的原始流处理器都是适配器类。ByteArrayOutputStream 继承了 OutputStream 类型，同时持有一个对 byte 数组的引用。它一个 byte 数组的接口适配成 OutputString 类型的接口，因此也是一个对象形式的适配器模式的应用。

FileOutputStream 继承了 OutputStream 类型，同时持有一个对 FileDiscriptor 对象的引用。这是一个将 FileDiscriptor 接口适配成 OutputStream 接口形式的对象型适配器模式。

Reader 类型的原始流处理器都是适配器模式的应用。StringReader 是一个适配器类，StringReader 类继承了 Reader 类型，持有一个对 String 对象的引用。它将 String 的接口适配成 Reader 类型的接口。

# 外观模式
概念：  
- 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用

使用场景：
- 为复杂的模块或子系统提供外界访问的模块

优点:
1. 减少系统相互依赖。 
2. 提高灵活性
3. 提高了安全性。

模式构成:
![facede](https://raw.githubusercontent.com/FameLsy/Images/master/design/facede.png)

代码解释:
1. 各个子系统类
2. 外观类类(Facede):核心，所有子系统方法在这里封装成一个方法
3. 客户端：只需要调用外观类类，无需关系其他子系统

子系统类(以高达为例，它内部有传感器、核心电脑、引擎等系统,每个都有一个start()方法)
```
/**
 * 子系统类
 * (高达核心电脑)
 * @author liisyu
 * @date 2019/2/23
 */
public class CoreComputer {
    public void start(){
        System.out.println("核心电脑，启动");
    }
}


/**
 * 子系统
 * (高达引擎)
 * @author liisyu
 * @date 2019/2/23
 */
public class Engine {
    public void start(){
        System.out.println("高达引擎，启动");
    }
}

/**
 * 子系统
 * (高达传感器)
 * @author liisyu
 * @date 2019/2/23
 */
public class Sensor {
    public void start(){
        System.out.println("高达传感器，启动");
    }
}
```

外观类，我们将所有子系统的start()方法集中Facede的start()方法中
```java
/**
 * 外观类
 * (一架高达)
 * @author liisyu
 * @date 2019/2/23
 */
public class Facede {
    private CoreComputer coreComputer;
    private Engine engine;
    private Sensor sensor;

    public Facede() {
        this.coreComputer = new CoreComputer();
        this.engine = new Engine();
        this.sensor = new Sensor();
    }

    /**
     * 高达启动！
     */
    public void start(){
        coreComputer.start();
        engine.start();
        sensor.start();
        System.out.println("高达启动完毕");
    };
}
```

客户端,直接创一个外观类，并调用start()方法，就可以开启全部的子系统
```java
/**
 * 客户端
 * @author liisyu
 * @date 2019/2/23
 */
public class Client {
    public static void main(String[] args) {
//        创建外观类
        Facede facede = new Facede();
//        启动,并不需要其他引擎系统，传感器系统，核心系统是怎么启动的
        facede.start();

    }
}
//print
核心电脑，启动
高达引擎，启动
高达传感器，启动
高达启动完毕
```
# 模板方法模式

概念：
- 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以再不改变算法结构的情况下，重新定义算法中的某些步骤

使用场景：
- 子类拥有多个共同的方法（算法不同），但这些方法执行的逻辑顺序相同

优点:
1. 封装不变部分，扩展可变部分
2. 提取公共代码，便于维护
3. 行为父类控制，子类实现

模式构成:
![template](https://raw.githubusercontent.com/FameLsy/Images/master/design/template.png)

代码解释:
1. 抽象类：将算法逻辑提取到模板方法，具体算法由子类提供
2. 子类实现：重写抽象类的抽象方法

抽象类
1. 模拟高达拼装过程，不同高达具体怎么拼装是不同的，但都是按先拼装头部(primitiveOperation1)，拼装四肢(primitiveOperation2),拼装完成(primitiveOperation3)这3个步骤
2. 抽象类也实现了一个不属于子类方法但必须的通用方法，高达出厂(concreteOperation)
3. 对于由子类实现的方法必须声明抽象

```java
/**
 * 抽象类
 *
 * @author liisyu
 * @date 2019/2/23
 */
public abstract class AbstractClass {
    /**
     * 模板方法
     */
    final void templateMethod(){
        primitiveOperation1();
        primitiveOperation2();
        primitiveOperation3();
        concreteOperation();
    }

    /**
     * 原始操作1
     * 属于子类操作的方法必须抽象
     */
    abstract void primitiveOperation1();

    /**
     * 原始操作2
     * 属于子类操作的方法必须抽象
     */
    abstract void primitiveOperation2();

    /**
     * 原始操作3
     * 属于子类操作的方法必须抽象
     */
    abstract void primitiveOperation3();

    /**
     * 属于本类的操作
     */
    void concreteOperation(){
        System.out.println("出厂");
    };
}
```

具体子类
```java
/**
 * 具体的子类
 * @author liisyu
 * @date 2019/2/23
 */
public class GaoDaClass extends AbstractClass {
    @Override
    void primitiveOperation1() {
        System.out.println("拼装TM合金头部");
    }

    @Override
    void primitiveOperation2() {
        System.out.println("拼装GDM四肢");
    }

    @Override
    void primitiveOperation3() {
        System.out.println("高达拼装完成");
    }
}

/**
 * 具体的子类
 * @author liisyu
 * @date 2019/2/23
 */
public class ZhaGuClass extends AbstractClass {
    @Override
    void primitiveOperation1() {
        System.out.println("拼装SM型头部");
    }

    @Override
    void primitiveOperation2() {
        System.out.println("拼装E3-DN四肢");
    }

    @Override
    void primitiveOperation3() {
        System.out.println("扎古拼装完成");
    }
}

```

使用,按照相同的逻辑顺序，拼装出了不同的高达
```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class TestMain {
    public static void main(String[] args) {
        AbstractClass concreteClass = new GaoDaClass();
        concreteClass.templateMethod();

        concreteClass = new ZhaGuClass();
        concreteClass.templateMethod();
    }
}
//print
拼装TM合金头部
拼装GDM四肢
高达拼装完成
出厂
拼装SM型头部
拼装E3-DN四肢
扎古拼装完成
出厂
```

# 迭代器模式
概念：
- 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

使用场景：
1. 访问一个聚合对象的内容而无须暴露它的内部表示
2. 需要为聚合对象提供多种遍历方式
3. 为遍历不同的聚合结构提供一个统一的接口

优点:
1. 它支持以不同的方式遍历一个聚合对象。 
2. 迭代器简化了聚合类。
3. 在同一个聚合上可以有多个遍历
4. 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

模式构成:
![iterator](https://raw.githubusercontent.com/FameLsy/Images/master/design/iterator.png)

代码解释:
1. 迭代器接口:提供hasNext()、remove()、next()方法
2. 容器接口:主要提供一个获取迭代器的方法
3. 迭代器实现类
4. 容器实现类

迭代器接口
```java

/**
 * 迭代器接口
 * (也可以直接实现java.util.Iterator)
 * @author liisyu
 * @date 2019/2/23
 */
public interface Iterator {
    /**
     *判断是否有下一个
     * @return
     */
    boolean hasNext();

    /**
     * 获取下一个
     * @return
     */
    Object next();

    /**
     * 删除（来自java.util.Iterator的remove()）
     */
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
}
```

容器接口
```java
/**
 * 集合容器
 * 通常包含一个获取迭代器的方法createIterator()
 * @author liisyu
 * @date 2019/2/23
 */
public interface Aggregate {
    /**
     * 添加成员
     * @param obj 成员
     */
    void add(Object obj);

    /**
     * 删除成员
     * @param obj 成员
     */
    void remove(Object obj);
    /**
     * 创建迭代器
     * @return 迭代器
     */
    Iterator createIterator();
}
```

迭代器实现类
```java
/**
 * 具体迭代器
 * 负责管理目前遍历的位置
 * @author liisyu
 * @date 2019/2/23
 */
public class ConcreteIterator implements Iterator {
    private List list;
    /**
     * 记录集合位置
     */
    private int cursor =0;


    public ConcreteIterator(List list) {
        this.list = list;
    }

    @Override
    public boolean hasNext() {
        if (cursor == list.size()) {
            return false;
        }
        return true;
    }

    @Override
    public Object next() {
        Object obj = null;
        if (this.hasNext()){
            obj = this.list.get(cursor++);
        }
        return obj;
    }

    @Override
    public void remove() {

    }
}
```
容器实现类
```java
/**
 * 容器实现类
 * @author liisyu
 * @date 2019/2/23
 */
public class ConcreteAggregate implements Aggregate {
    private List list;

    public ConcreteAggregate() {
        list = new ArrayList();
    }

    @Override
    public void add(Object obj) {
        list.add(obj);
    }

    @Override
    public void remove(Object obj) {
        list.remove(obj);
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator(list);
    }
}
```

使用,对于遍历一个对象，变得省力
```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class TestMain {
    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        aggregate.add(new Object());
        aggregate.add(new Object());
        aggregate.add(new Object());

        Iterator iterator = aggregate.createIterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            System.out.println(obj);
        }

    }
}
```

## 空迭代器
对于一个没有内容可以遍历，该怎么写createIterator,返回一个如下的空迭代器，其hasNext()一直返回false
```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class NullIterator implements Iterator {
    @Override
    public boolean hasNext() {
        return false;
    }

    @Override
    public Object next() {
        return null;
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }
}
```


# 组合模式

概念：
1. 将对象组合成树形状接口来表示"整体/部分"层次结构，组合能让客户以一致的方式处理这个对象以及对象组合
2. 组合模式能用树形方式创建对象结构，树里包含了组合以及个别的对象

使用场景：
- 部分、整体场景，如树形菜单，文件、文件夹的管理。

优点：
 1. 高层模块调用简单
 2. 节点自由增加。

缺点
- 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

模式构成:
![composite](https://raw.githubusercontent.com/FameLsy/Images/master/design/composite.png)

代码解释
1. 组合抽象类:为组合中所有对象定义一个接口，不管是组合还是叶节点
2. 具体组合:定义组合 的行为，而且具有子节点
3. 叶节点：没有孩子，虽然继承了add等方法但是没有用

组合抽象类
```java
/**
 * 为组合中所有对象定义一个接口，不管是组合还是叶节点
 * @author liisyu
 * @date 2019/2/23
 */
public abstract class Component {
    /**
     * 操作
     */
    public void operation(){
        throw new UnsupportedOperationException();
    };

    /**
     * 添加组合
     * @param component 添加的组合
     */
    public void add(Component component){
        throw new UnsupportedOperationException();
    };

    /**
     * 删除组合
     * @param component 删除的组合
     */
    public void remove(Component component){
        throw new UnsupportedOperationException();
    };

    /**
     * 获取子节点
     * @return
     */
    public Component getChild(int i){
        throw new UnsupportedOperationException();
    }
}
```

具体组合
```java
/**
 * 定义组合 的行为，而且具有子节点
 * @author liisyu
 * @date 2019/2/23
 */
public class Composite extends Component {
    List<Component> list;
    String description;
    public Composite(String description) {
        list = new ArrayList<>();
        this.description = description;
    }

    @Override
    public void operation() {
        System.out.println(description);
    }

    @Override
    public void add(Component component) {
        list.add(component);
    }

    @Override
    public void remove(Component component) {
        list.remove(component);
    }

    @Override
    public Component getChild(int i) {
        return (Component)list.get(i);
    }
}
```

叶节点
```java
/**
 * 叶节点
 * 没有孩子，虽然继承了add等方法但是没有用
 * @author liisyu
 * @date 2019/2/23
 */
public class Leaf extends Component{
    String description;
    public Leaf(String description) {
        this.description = description;
    }

    @Override
    public void operation() {
        System.out.println(description);
    }

}
```

使用
```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class TestMain {
    public static void main(String[] args) {
        Composite composite = new Composite("一号组合");
        Leaf leaf = new Leaf("一号叶节点");
        //放入
        composite.add(leaf);

        Composite composite2 = new Composite("二号组合");
        Leaf leaf2 = new Leaf("二号叶节点");
        //放入
        composite2.add(leaf2);

        //将composite2放入composite
        composite.add(composite2);

        //现在有如下结构
//        Composite
//            |
//      leaf      composite2
//                     |
//                    leaf2

//        验证
        composite.operation();
        composite.getChild(0).operation();

        Component child = composite.getChild(1);
        child.operation();

        child.getChild(0).operation();
    }
}
//print
一号组合
一号叶节点
二号组合
二号叶节点
```



# 代理模式

概念：
- 使用代理对象完成用户请求，屏蔽用户对真是对象的访问

使用场景：

优点：
1. 职责清晰
2. 高扩展性
3. 智能化
4. 可以对代理方法添加业务逻辑

缺点
1. 处理速度可能变慢
2. 代理模式实现可能非常复杂

## 静态代理（完成延迟加载）

在系统启动时，将消耗资源最多的方法都使用代理模式分离，可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时再由代理类单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。

模式构成:
![proxy](https://raw.githubusercontent.com/FameLsy/Images/master/design/proxy.png)

代码解释
1. 主题接口:真实对象和代理对象都实现了该接口
2. 代理类:持有Subject引用，可以将请求转发给Subject
3. 真实对象

主题接口
```java
/**
 * 主题接口
 * 真实对象和代理对象都实现了该接口
 * @author liisyu
 * @date 2019/2/23
 */
public interface Subject {
    /**
     * 处理请求
     */
    void request();
}

```
代理类
```java
/**
 * 代理类
 * 持有Subject引用，可以将请求转发给Subject
 * @author liisyu
 * @date 2019/2/23
 */
public class Proxy implements Subject {
    private Subject real;
    @Override
    public void request() {
        //可以插入其他业务逻辑
        // 真正需要的时候才创建对象
        if (real == null){
            real = new RealSubject();
        }
        real.request();
        //可以插入其他业务逻辑

    }
}
```

真是对象
```java
/**
 * 真实对象
 * 真正做事的类
 * @author liisyu
 * @date 2019/2/23
 */
public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("真实地处理请求");
    }
}

```

测试
```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class TestMain {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
//        只有用到时，才会创建真实对象
        proxy.request();
    }
}

// print
//真实地处理请求

```

## 动态代理
概念
1. 动态代理是指在运行时动态生成代理类
2. 生成动态代理类的方法很多，JDK自带的动态代理、CGLIB、Javassist,ASM库(推荐CGLIB)
优点：
1. 不需要为真实主题写一个形式上完全一样的封装类，假如主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；
2. 使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。

JDK方式生成代理对象,对代理类进行了如下修改

```java
/**
 * @author liisyu
 * @date 2019/2/23
 */
public class ProxyHandler implements InvocationHandler {
    private Subject real;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (real == null){
            real =  new RealSubject();
            method.invoke(real,args);
        }
        return null;
    }

    /**
     * 生成代理对象
     */
    public static Subject createProxy(){
        //参数含义
        //1. 类加载器
        //2. 代码要用来代理的接口,接口决定我们要代理哪些方法
        //3. 一个InvocationHandler类,决定用谁来完成代理操作
        Subject proxy = (Subject)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Subject.class},new ProxyHandler());
        return proxy;
    }
}
```

测试,当使用代理类执行时，会交给ProxyHandler的.invoke()方法处理
```java
public class TestMain {
    public static void main(String[] args) {
        Subject proxy =  ProxyHandler.createProxy();
        proxy.request();
    }
}
```



# 模式

概念：

使用场景：

优点：

缺点

模式构成:
![适配器](https://raw.githubusercontent.com/FameLsy/Images/master/design/适配器.png)

代码解释

