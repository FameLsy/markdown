---
title: 设计模式
tags: 
- 设计模式
categories: 
- 设计模式
---

# 一、策略模式
概念：定义了算法族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户。（通俗的将就是将变化的部分和不变化的部分独立开）

场景分析:模拟鸭子游戏    
需求：设计鸭子
1. 鸭子存在不变的部分，如都有显示方法display()
2. 鸭子存在可变的部分，如只有部分鸭子才会飞行(fly())

思路：

一：继承  
继承后不会飞的鸭子覆盖fly()后什么也不做  
问题： 以后每次有新的鸭子，每次都要检查是否会飞。而且一旦改动父类的fly,所有子类都可能被影响

二：接口  
对于会飞的鸭子，实现Flyable接口  
问题：可能我现在对会飞的鸭子是愉快的飞，可以后可能改为愉快的起飞！还得将实现类一个个的改

各个缺陷：
1. 继承：改变父类会影响到所有子类
2. 接口：一定意义上可以解决问题，但接口不具备实现代码，无法达到代码服用。（这也意味着要改的话，就要修改每个实现接口的子类的方法）

真正的解决办法：策略模式  
将会变化的部分封装起来，与不会变化的部分独立开，互不影响  

现在，将fly行为提取成FlyBehavior接口,对于各种鸭子的飞行行为，设置为其实例
```java
interface FlyBehavior{
    void fly()
}
// 这个实现类表示鸭子靠翅膀飞行
class FlyWithWings implements FlyBehavior(){
    void fly(System.out.println("我靠翅膀飞"));
}
// 这个实现类表示鸭子靠不会飞
class FlyNoWay implements FlyBehavior(){
    void fly(System.out.println("我不会飞"));
}
```
那么Duck类就会改为
```java
abstract class Duck{
    //变量被声明为接口类型
    FlyBehavior aFlyBehavior;
    // 使用该方法代替以前的fly()
    void performFly(){
        aFlyBehavior.fly();
    };
}
```
比方说有一个MallardDuck(野鸭),会飞
```java
class MallardDuck extends Duck{
    public MallardDuck(){
        // 继承了父类的aFlyBehavior，而实例变量是FlyWIthWings
        aFlyBehavior = new FlyWIthWings();
    }
}
```
除此之外，还可以在动态设定行为，而不是在鸭子构造器内实例化
```java
class MallardDuck extends Duck{
    public MallardDuck(){}
    public void setFlyBehaivor(FlyBehavior aFlyBehavior){
          // 继承了父类的aFlyBehavior，而实例变量是FlyWIthWings
        hits.aFlyBehavior = aFlyBehavior;
    }
}
```
或者有一只会乱飞的鸭子，就可以
```java
// 这个实现类表示鸭子乱飞
class CrazyFly implements FlyBehavior(){
    void fly(System.out.println("我乱飞"));
}   

class CrazyDuck extends Duck{
    public CrazyDuck(){}
    public void setFlyBehaivor(FlyBehavior aFlyBehavior){
          // 继承了父类的aFlyBehavior，而实例变量是FlyWIthWings
        hits.aFlyBehavior = aFlyBehavior;
    }
}
```

# 观察者模式

概念： 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新。

场景分析：天气预报站
需求: 
1. 天气预报站会更新天气信息，可通过getter方法获取
2. 布告栏，用以显示更新信息
3. 一旦信息更新，布告栏及时更新显示

思路：  
1. 气象站只有一个
2. 布告栏有多个
3. 一对多的关系

解决：观察者模式
1. 由主图(Subject)和观察者(Observer)两个部分组成
2. 主题和观察者是一堆多的关系

主题(Subject):
1. 管理着某些数据
2. 当主题数据改变时，会通知观察者
3. 主题用一个共同的接口来更新观察者

观察者(Observer):  
1. 订阅主题
2. 在已订阅的主题更新时可以接收到更新
3. 对于没有订阅的主题就不会收到更新

实例：

主题接口,应该拥有注册，删除，通知观察者三个功能
```java
public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}
```

观察者接口，应该接收更新数据的功能
```java
public interface Observer {
    void update(Object[] objects);
}
```

主题具体实现类，除了实现三个功能方法外，还添加了两个方法，用于数据更改和发通知。
```java

public class WetherData implements Subject {
    private ArrayList observers;
//    一些气象数据
    private float temperature;
    private float humidity;
    private float pressure;

    public WetherData() {
        this.observers = new ArrayList();
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i > 0) observers.remove(i);
    }

    @Override
    public void notifyObservers() {
        for (int i = 0; i < 0; i++){
            Observer o = (Observer)observers.get(i);
            o.update(temperature, humidity,pressure);//更新
        }

    }

    /**
     * 数据更改时启用更新通知
     */
    public void measurementsChanged() {
        notifyObservers();
    }

    /**
     * 更新数据方法
     * @param temperature
     * @param humidity
     * @param pressure
     */
    public void setMeasurements(float temperature, float humidity, float pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        //调用数据更改方法
        measurementsChanged();
    }
}

```
观察者实现类
```java
public class CurrentConditionsDisplay implements Observer {
    @Override
    public void update(float temperature, float humidity, float pressure) {
        //...
    }
}
```

此时，只要创建WetherData实例对象，并通过registerObserver()注册观察者。一旦调用setMeasurements()方法，就会将更新自动通知给已经注册的观察者。

此外,在java.util包中，已经内置了观察者模式的相关接口(Observer和Observerable[已弃用])并留下了以下注释  
要研究的话，可以去java.beans包研究
```java
 * @deprecated
 * This class and the {@link Observer} interface have been deprecated.
 * The event model supported by {@code Observer} and {@code Observable}
 * is quite limited, the order of notifications delivered by
 * {@code Observable} is unspecified, and state changes are not in
 * one-for-one correspondence with notifications.
 * For a richer event model, consider using the
 * {@link java.beans} package.  For reliable and ordered
 * messaging among threads, consider using one of the concurrent data
 * structures in the {@link java.util.concurrent} package.
 * For reactive streams style programming, see the
 * {@link java.util.concurrent.Flow} API.
```