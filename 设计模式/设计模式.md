---
title: 设计模式
date: 2019 01-01 00:00:01
tags: 
- 设计模式
categories: 
- 设计模式
---

# 策略模式
概念：  
1. 定义了算法族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户（
2. 通俗的将就是将变化的部分和不变化的部分独立开

使用场景：
 1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 
 2. 一个系统需要动态地在几种算法中选择一种。 
 3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。(在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护)

优点:
1. 算法可以自由切换
2. 避免使用多重条件判断
3. 扩展性良好。

模式构成:
1. 需要一个Strategy接口来封装策略方法，供实现类以不同算法实现
2. Context类使用该策略，通过注入不同的策略实现类，来完成一个方法不同的算法

![策略模式](https://raw.githubusercontent.com/FameLsy/Images/master/design/Strategy.png)

代码解释:
1. 抽象策略(Strategy)：将通用的方法封装起来
2. 具体策略(StrategyImpl*):对方法实现不同的算法
3. 策略使用类(Context): 通过注入不同的具体策略，来实现不同的算法

创建一个策略接口，定义一个通用的策略方法
```java
package com.liisyu.strategypattern;

/**
 * 策略模式
 * @author liisyu
 */
public interface Strategy {
    /**
     * some method to invoke
     * @param objects param
     * @return Object
     */
    Object doMethod(Object[] objects);
}
```

创建策略接口实体类,根据不同需求实现不同的策略方法
```java
/**
 * StrategyImpl 1
 * @author liisyu
 */
public class StrategyImplAdd  implements Strategy{
    @Override
    public Object doMethod(Object[] objects) {
        //do for something with StrategyImpl_1.doMethod;
        return null;
    }
}

/**
 * StrategyImpl 12
 * @author liisyu
 */
public class StrategyImplDelete implements Strategy{
    @Override
    public Object doMethod(Object[] objects) {
        //do for something with StrategyImplDelete.doMethod;
        return null;
    }
}

/**
 * StrategyImpl 3
 * @author liisyu
 */
public class StrategyImplUpdate implements Strategy{
    @Override
    public Object doMethod(Object[] objects) {
        //do for something with StrategyImplUpdate.doMethod;
        return null;
    }
}
```

创建使用策略的类
```java
/**
 * a class that uses strategy
 * @author liisyu
 */
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy){
        this.strategy = strategy;
    }

    public Object executeStrategy(Object[] objects){
        return strategy.doMethod(objects);
    }

}
```

使用,通过传入不同的策略实现类，实现不同的需求
```java
/**
 * Test Class
 * @author liisyu
 */
public class TestMain {
    public static void main(String[] args) {
        Context context = new Context(new StrategyImplAdd());
        context.executeStrategy(null);

        context = new Context(new StrategyImplDelete());
        context.executeStrategy(null);

        context = new Context(new StrategyImplUpdate());
        context.executeStrategy(null);


    }
}
```

# 观察者模式

概念： 
-. 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新

使用场景：
1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
2. 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
3. 一个对象必须通知其他对象，而并不知道这些对象是谁。
4. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

优点:
1. 观察者和主题是抽象耦合的
2. 改变观察者或主题，并不会影响另一方

模式构成：

![observer](https://raw.githubusercontent.com/FameLsy/Images/master/design/observer.png)

代码解释:
1. 主题接口和观察者实为多对多，或一对多，多对一的关系，这里使用了Subject接口和Observer接口
2. 主题实现类包含了观察者，方便注册，删除，通知观察者
3. 观察者包含了主题接口，注册了该接口即可收到主题的通知 

主题接口，包含注册、删除，通知观察者的三个方法

```java
/**
 * 主题类
 * @author  liisyu
 * @date 2019/02/22
 */
public interface Subject{
    /**
     * 注册观察者
     * @param observer 观察者
     */
    void registerObserver(Observer observer);

    /**
     * 删除观察者
     * @param observer 观察者
     */
    void removeObserver(Observer observer);

    /**
     * 提示所有观察者
     */
    void notifyObservers();
}
```

观察者接口,主要包含一个更新信息的方法
```java
/**
 * 观察者接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Observer {
    /**
     * 用于观察者更新
     * @param  info 参数
     */
    void update(String info);

    //观察者的其他方法
}

```

主题实现类，除了属性外，还内置了一个观察者集合，用于保存注册的观察者
```java
/**
 * @author  liisyu
 * @date 2019/02/22
 */
public class SubjectImpl implements Subject {
    private List<Observer> observers;

    private String info;

    public SubjectImpl() {
        observers = new ArrayList<>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        int i = observers.indexOf(observer);
        if (i >= 0) {
            observers.remove(i);
        }

    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers){
            observer.update(info);
        }
    }

    /**
     * 信息改变时，提醒所有观察者
     */
    public void infoChange(){
        notifyObservers();
    }

    /**
     * 修改信息，并触发改变
     * @param info 新的状态
     */
    public void setStatus(String info) {
        this.info = info;
        System.out.println("信息改变成: " + this.info);
        infoChange();
    }

    //其他方法
}
```
观察者实现类，内置了一个主题接口，用于注册主题(如果是多个主题，也需要用到集合)
```java
/**
 * 观察者实现类
 * @author liisyu
 * @date 2019/02/22
 */
public class ObserverImpl implements Observer {
    private String info;
    private Subject subject;

    public ObserverImpl(Subject subject) {
        this.subject = subject;
        subject.registerObserver(this);
    }

    @Override
    public void update(String info) {
        this.info = info;
        System.out.println("观察者更新了");
    }

    public Subject getSubject() {
        return subject;
    }

    public void setSubject(Subject subject) {
        this.subject = subject;
    }
}
```

使用
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        SubjectImpl subject = new SubjectImpl();

        ObserverImpl observer = new ObserverImpl(subject);

        subject.setStatus("更新");
    }
}
```

# 装饰者模式
概念:
- 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

使用场景：  
1. 扩展一个类的功能
2. 动态增加功能
3. Java的I/O流

优点:  
- 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

模式构成:  

![装饰者模式](https://raw.githubusercontent.com/FameLsy/Images/master/design/Decorator.png)

代码解释:
1. 需要一个顶级的组件类或接口
2. 被装饰者和装饰类都需要继承/实现它
3. 装饰者需要注入被装饰者的类，以便在原有基础上添加新功能

创建组件抽象类(也可以是接口),我们将对它的两个方法进行装饰
```java
/**
 * 组件抽象类
 * @author liisyu
 * @date 2019/02/22
 */
public abstract class BaseComponent {
    String description = "Unknown component";
    /**
     * 组件的方法A
     */
    public String getDescription(){
        return description;
    }

    /**
     * 获取功能
     * @return 功能描述
     */
   public abstract String features();
}
```
组件子类,把被装饰者当成了机器人，那么装饰器就是为它装备各种武器
```java
/**
 * 头部组件(就当拼装机器人了)
 * @author liisyu
 * @date 2019/02/22
 */
public class RobotComponent extends BaseComponent{
    public RobotComponent() {
        description = "我是一个机器人";
    }

    @Override
    public String features() {
        return "战争武器";
    }
}
```
创建基本的装饰器,它通用扩展于BaseComponent
```java
/**
 * 装饰器
 * @author liisyu
 * @date 2019/02/22
 */
public abstract class BaseDecorator extends BaseComponent{
    /**
     * 这里重新抽象化了getDescription,目的就是让其子类不得不重写它
     * @return 返回描述
     */
    @Override
    public abstract String getDescription();
}
```
装饰器子类,这里定义了装备枪和炸弹的装饰器
```java
/**
 * 装饰器实体类
 * @author liisyu
 * @date 2019/02/22
 */
public class GunDecorator extends BaseDecorator {
    /**
     * 用一个变量引用被装饰柱
     */
    private BaseComponent baseComponent;

    /**
     * 将被装饰者传入到装饰器中
     * @param baseComponent
     */
    public GunDecorator(BaseComponent baseComponent) {
        this.baseComponent = baseComponent;
    }

    @Override
    public String getDescription() {
        return baseComponent.getDescription() + ",装备枪";
    }

    @Override
    public String features() {
        return baseComponent.features() + ",大范围杀伤力,战斗力+5";
    }
}

/**
 * 装饰器实体类
 * @author liisyu
 * @date 2019/02/22
 */
public class BombDecorator extends BaseDecorator {
    private BaseComponent baseComponent;

    public BombDecorator(BaseComponent baseComponent) {
        this.baseComponent = baseComponent;
    }

    @Override
    public String getDescription() {
        return baseComponent.getDescription() + ",装备炸弹";
    }

    @Override
    public String features() {
        return baseComponent.features() + ",攻击范围+500px";
    }
}

```

使用,先创建了一个机器人，然后分别装上枪和炸弹
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        //创建一个机器人组件
        BaseComponent baseComponent = new RobotComponent();
        System.out.println(baseComponent.getDescription() + "&&" + baseComponent.features());

        //装备枪
        baseComponent = new GunDecorator(baseComponent);
        System.out.println(baseComponent.getDescription() + "&&" + baseComponent.features());

        //装备炸弹
        baseComponent = new BombDecorator(baseComponent);
        System.out.println(baseComponent.getDescription() + "&&" + baseComponent.features());
    }
}

//print
我是一个机器人&&战争武器
我是一个机器人,装备枪&&战争武器,大范围杀伤力,战斗力+5
我是一个机器人,装备枪,装备炸弹&&战争武器,大范围杀伤力,战斗力+5,攻击范围+500px

```

# 工厂模式
工厂模式有三个分类
1. 简单工厂模式
2. 工厂方法模式
3. 抽象工厂模式

概念：  
1. 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。
2. 

优点:
1. 一个调用者想创建一个对象，只要知道其名称就可以了。 
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
32. 屏蔽产品的具体实现，调用者只关心产品的接口。

## 简单工厂模式

使用场景：
- 创建的对象较少


模式构成:

![simple](https://raw.githubusercontent.com/FameLsy/Images/master/design/simple.png)

代码解释:（以机器人厂为例）
1. 抽象接口(Robot): 子类定制不同实例
2. 具体实例
3. 工厂：从工厂获取各类实例(可以使用反射进行优化)

创建一个接口
```java
/**
 * 机器人接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Robot {
    /**
     * 机器人出击方法描述
     */
    void go();
}
```
实例
```java
/**
 * 机器人实现类（扎古）
 * @author liisyu
 * @date 2019/02/22
 */
public class Zhagu implements Robot {
    public Zhagu() {
        System.out.println("扎古，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速500公里/小时");
    }
}

/**
 * 机器人实现类(高达Zero)
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaZero implements Robot {
    public GaodaZero() {
        System.out.println("高达，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速1500公里/小时，瞬移100米");
    }
}
```

工厂类,这里提供了两种方式进行获取实例
```java
/**
 * 机器人工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class RobotFactory {
    /**
     * 获取机器人
     * @param robotType 机器人类型
     * @return 机器人实例
     */
    public static Robot getRobot(String robotType){
        if (robotType == null || robotType.length() == 0){
            return null;
        }
        if ("zhagu".equalsIgnoreCase(robotType)) {
            return new Zhagu();
        }else if("gaoda".equalsIgnoreCase(robotType)){
            return new GaodaZero();
        }
        return null;
    }

    /**
     * 反射方式获取机器人
     * @param robotType 机器人类型
     * @return  机器人实例
     */
    public static Robot getRobot2(String robotType) {
        Robot robot = null;
        try {
            robot =  (Robot) Class.forName("com.liisyu.factory.simple." + robotType).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return robot;
    }
}

```

使用
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        Robot robot = RobotFactory.getRobot("gaoda");
        robot.go();

        robot = RobotFactory.getRobot2("zhagu");
        robot.go();
    }
}

//print
高达，出击！
时速1500公里/小时，瞬移100米
扎古，出击！
时速500公里/小时
```
##  工厂方法模式

使用场景：
1. 一个类不知道它所需要的对象的类
2. 一个类通过其子类来指定创建哪个对象
3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中

模式构成:

![mehotd](https://raw.githubusercontent.com/FameLsy/Images/master/design/mehotd.png)

代码解释
1. 抽象工厂类
2. 抽象对象类
3. 工厂类实现，每一个对象对应一个工厂
4. 对象实现类

工厂接口
```java
/**
 * 工厂接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Factory {
    /**
     * 工厂方法,所有子类必须继承
     */
    Robot factoryMethod();
}

```

机器人接口
```java
/**
 * 机器人接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Robot {
    /**
     * 机器人出击方法描述
     */
    void go();
}

```

工厂实现类
```java
/**
 * 高达Zero工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaFactory implements Factory{

    @Override
    public Robot factoryMethod() {
        return new GaodaZero();
    }
}


/**
 * 扎古工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class ZhaguFactory implements Factory {

    @Override
    public Robot factoryMethod() {
        return new Zhagu();
    }
}

```

对象实例
```java
/**
 * 机器人实现类（扎古）
 * @author liisyu
 * @date 2019/02/22
 */
public class Zhagu implements Robot {
    public Zhagu() {
        System.out.println("扎古，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速500公里/小时");
    }
}

/**
 * 机器人实现类(高达Zero)
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaZero implements Robot {
    public GaodaZero() {
        System.out.println("高达，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速1500公里/小时，瞬移100米");
    }
}
```

使用,实例化不同工厂，获取相应的对象
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        Robot robot = new GaodaFactory().factoryMethod();
        robot.go();

        robot = new ZhaguFactory().factoryMethod();
        robot.go();
    }
}
//print
高达，出击！
时速1500公里/小时，瞬移100米
扎古，出击！
时速500公里/小时
```

## 抽象工厂模式

使用场景：
- 工厂不止创建一个对象

模式构成:

![abstract](https://raw.githubusercontent.com/FameLsy/Images/master/design/abstract.png)

代码解释:
1. 抽象工厂类（复数）
2. 抽象对象类（复数）
3. 工厂类实现，每一个对象对应一个工厂
4. 对象实现类

工厂接口,包含了两个方法，获取机器人和武器
```java
/**
 * 工厂接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Factory {
    /**
     * 工厂方法,所有子类必须继承
     * @return 机器人实体类
     */
    Robot factoryMethod();

    /**
     * 工厂方法,所有子类必须继承
     * @return 武器实体类
     */
    Arms factoryMethod2();
}
```

机器人接口
```java
/**
 * 机器人接口
 * @author liisyu
 * @date 2019/02/22
 */
public interface Robot {
    /**
     * 机器人出击方法描述
     */
    void go();
}

```
工厂实现类,高达工厂产高达和炸弹，扎古工厂产扎古和枪
```java
/**
 * 高达Zero工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaFactory implements Factory {

    @Override
    public Robot factoryMethod() {
        return new GaodaZero();
    }

    @Override
    public Arms factoryMethod2() {
        return new Bomb();
    }
}


/**
 * 扎古工厂
 * @author liisyu
 * @date 2019/02/22
 */
public class ZhaguFactory implements Factory {

    @Override
    public Robot factoryMethod() {
        return new Zhagu();
    }

    @Override
    public Arms factoryMethod2() {
        return new Guns();
    }
}

```

对象实例
```java
/**
 * 机器人实现类（扎古）
 * @author liisyu
 * @date 2019/02/22
 */
public class Zhagu implements Robot {
    public Zhagu() {
        System.out.println("扎古，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速500公里/小时");
    }
}

/**
 * 机器人实现类(高达Zero)
 * @author liisyu
 * @date 2019/02/22
 */
public class GaodaZero implements Robot {
    public GaodaZero() {
        System.out.println("高达，出击！");
    }

    @Override
    public void go() {
        System.out.println("时速1500公里/小时，瞬移100米");
    }
}
```

使用
```java
/**
 * Test Class
 * @author liisyu
 * @date 2019/02/22
 */
public class TestMain {
    public static void main(String[] args) {
        Factory factory = new GaodaFactory();
        Robot robot = factory.factoryMethod();
        Arms arms = factory.factoryMethod2();
        robot.go();
        arms.run();

        factory = new ZhaguFactory();
        robot = factory.factoryMethod();
        arms = factory.factoryMethod2();
        robot.go();
        arms.run();
    }
}
//print
高达，出击！
时速1500公里/小时，瞬移100米
爆炸输出
扎古，出击！
时速500公里/小时
单点高伤害
```

# 单例模式

概念：  
1. 对象只有一个实例
2. 静态变量也可以实现单例，但越是耗资源的对象，就越浪费（如果只在需要时创建，就可以避免这种浪费）
3. 分懒汉式和饿汉式

使用场景：
1. 对于线程池、缓存、对话框、注册表、日志对象、充当打印机等，这些需要保证只有一个实例对象
2. 

优点:
1. 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
2. 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

## 饿汉式
1. 饿汉式（线程安全）
2.  饿汉式（枚举实现）
全局的单例实例在类装载时构建

### 饿汉式（线程安全）
```java
/**
 * 饿汉式线程安全
 * @author liisyu
 * @date 2019/02/22
 */
public class Hungry {

    /**
     * 静态初始化变量，保证单例且线程安全
     */
    private static Hungry hungry = new Hungry();

    /**
     * 私有化构造器，防止创建
     */
    private Hungry(){};
    public static Hungry getHungry() {
        return hungry;
    }

    public void doMethod(){
        System.out.println("do something");
    }
}
```

### 饿汉式（枚举实现）
```java
/**
 * 饿汉式枚举
 * @author liisyu
 * @date 2019/02/22
 */
public enum HungryEnum {
    /**
     * 唯一实体类
     */
    HUNGRY_INSTANCE;

    public void doMethod(){
        System.out.println("do something");
    }
}

```

## 懒汉式
1. 懒汉式（非线程安全)
2. 懒汉式（线程安全）
3. 懒汉式(双重检查加锁版本)
4. 懒汉式（登记式/静态内部类方式）


### 懒汉式（非线程安全)
```
/**
 * 懒汉式非线程安全
 * @author liisyu
 * @date 2019/02/22
 */
public class Lazy {
    private static Lazy lazy;

    private Lazy(){};

    public static Lazy getLazy(){
        if (lazy == null){
            //这里有可能出现线程问题
            lazy = new Lazy();
        }
        return lazy;
    }
}
```
### 懒汉式（线程安全）
如果想要线程安全，可以使用synchronized,不过每次获取都需要经过一遍锁，不推荐
```
   public static synchronized Lazy getLazy(){
        if (lazy == null){
            //这里有可能出现线程问题
            lazy = new Lazy();
        }
        return lazy;
    }
```

###  懒汉式(双重检查加锁版本)
1. 第一次先检查是否为null，再进入同步
2. 第二次检查是否为Null，null才创建实例。
```java
/**
 * 懒汉式(双重检查加锁版本)
 * @author liisyu
 * @date 2019/02/22
 */
public class LazyDoubleLock {
    /**
     * volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量
     */
    private volatile static LazyDoubleLock lazy;
    
    private LazyDoubleLock() {
    }
    
    public static LazyDoubleLock getInstance() {
        //检查实例，如果不存在，就进入同步代码块
        if (lazy == null) {
            //只有第一次才彻底执行这里的代码
            synchronized(LazyDoubleLock.class) {
                //进入同步代码块后，再检查一次，如果仍是null，才创建实例
                if (lazy == null) {
                    lazy = new LazyDoubleLock();
                }
            }
        }
        return lazy;
    }
}

```
### 懒汉式（登记式/静态内部类方式）
只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类(只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题)
```java
/**
 * 懒汉式(静态内部类方式)
 * @author liisyu
 * @date 2019/02/22
 */
public class LazyInnerClass {
    private static class SingletonHolder {
        private static final LazyInnerClass LZAY = new LazyInnerClass();
    }
    private LazyInnerClass (){}

    public static final LazyInnerClass getInstance() {
        return SingletonHolder.LZAY;
    }
}
```



模式构成:

代码解释:
# 模式
概念：

使用场景：

优点:

模式构成:

代码解释:
# 代理模式
