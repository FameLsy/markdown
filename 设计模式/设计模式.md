---
title: 设计模式
tags: 
- 设计模式
categories: 
- 设计模式
---

# 一、策略模式
概念：定义了算法族,分别封装起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户。（通俗的将就是将变化的部分和不变化的部分独立开）

场景分析:模拟鸭子游戏
类：Duck类
```java
abstract class Duck{
    void display();
    void fly();
}
```
1. Duck类存在不变的部分，如外观(display())
2. Duck类存在可变的部分，如飞行(fly())

问题：如何设计，能合理的将一些未来可变的部分解耦

解决方式一：继承  
继承后不会飞的鸭子覆盖fly()后什么也不做  
问题： 以后每次有新的鸭子，每次都要检查是否会飞。而且一旦改动父类的fly,所有子类都可能被影响

解决方式二：接口  
对于会飞的鸭子，实现Flyable接口  
问题：可能我现在对会飞的鸭子是愉快的飞，可以后可能改为愉快的起飞！还得将实现类一个个的改

各个缺陷：
1. 继承：改变父类会影响到所有子类
2. 接口：一定意义上可以解决问题，但接口不具备实现代码，无法达到代码服用。（这也意味着要改的话，就要修改每个实现接口的子类的方法）

真正的解决办法：策略模式  
将会变化的部分封装起来，与不会变化的部分独立开，互不影响  

现在，将fly行为提取成FlyBehavior接口,对于各种鸭子的飞行行为，设置为其实例
```java
interface FlyBehavior{
    void fly()
}
// 这个实现类表示鸭子靠翅膀飞行
class FlyWithWings implements FlyBehavior(){
    void fly(System.out.println("我靠翅膀飞"));
}
// 这个实现类表示鸭子靠不会飞
class FlyNoWay implements FlyBehavior(){
    void fly(System.out.println("我不会飞"));
}
```
那么Duck类就会改为
```java
abstract class Duck{
    //变量被声明为接口类型
    FlyBehavior aFlyBehavior;
    // 使用该方法代替以前的fly()
    void performFly(){
        aFlyBehavior.fly();
    };
}
```
比方说有一个MallardDuck(野鸭),会飞
```java
class MallardDuck extends Duck{
    public MallardDuck(){
        // 继承了父类的aFlyBehavior，而实例变量是FlyWIthWings
        aFlyBehavior = new FlyWIthWings();
    }
}
```
除此之外，还可以在动态设定行为，而不是在鸭子构造器内实例化
```java
class MallardDuck extends Duck{
    public MallardDuck(){}
    public void setFlyBehaivor(FlyBehavior aFlyBehavior){
          // 继承了父类的aFlyBehavior，而实例变量是FlyWIthWings
        hits.aFlyBehavior = aFlyBehavior;
    }
}
```
或者有一只会乱飞的鸭子，就可以
```java
// 这个实现类表示鸭子乱飞
class CrazyFly implements FlyBehavior(){
    void fly(System.out.println("我乱飞"));
}   

class CrazyDuck extends Duck{
    public CrazyDuck(){}
    public void setFlyBehaivor(FlyBehavior aFlyBehavior){
          // 继承了父类的aFlyBehavior，而实例变量是FlyWIthWings
        hits.aFlyBehavior = aFlyBehavior;
    }
}
```
